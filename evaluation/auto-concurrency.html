<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Auto Concurrency - keyword generics initiative</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../updates/index.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2022-07-27-announcing-the-keyword-generics-initiative.html">2022-07-27: Announcing the Keyword Generics Initiative</a></li><li class="chapter-item "><a href="../updates/2023-02-23-keyword-generics-progress-report-feb-2023.html">2023-02-23: Keyword Generics Progress Report February 2023</a></li><li class="chapter-item "><a href="../updates/2024-02-09-extending-rusts-effect-system.html">2024-02-09: Extending Rust's Effect System</a></li></ol></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item expanded "><a href="../evaluation/index.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/index.html">Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/_template.html">Template</a></li><li class="chapter-item "><a href="../evaluation/syntax/attributes.html">Attributes</a></li><li class="chapter-item "><a href="../evaluation/syntax/const-bool-like-effects.html">Const-bool like effects</a></li><li class="chapter-item "><a href="../evaluation/syntax/effect-as-a-clause.html">Effect as a clause</a></li><li class="chapter-item "><a href="../evaluation/syntax/postfix-question-mark.html">Postfix question mark</a></li><li class="chapter-item "><a href="../evaluation/syntax/where-effect-bounds.html">Where effect bounds</a></li></ol></li><li class="chapter-item "><a href="../evaluation/pattern-types.html">Pattern Types and Backwards Compatibility</a></li><li class="chapter-item expanded "><a href="../evaluation/auto-concurrency.html" class="active">Auto Concurrency</a></li></ol></li><li class="chapter-item "><a href="../explainer/index.html">üìö Draft RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/effect-generic-trait-declarations.html">Effect-Generic Trait Declarations</a></li><li class="chapter-item "><a href="../explainer/effect-generic-bounds-and-functions.html">Effect-Generic Bounds and Functions</a></li><li class="chapter-item "><div>Effect-Generic Types</div></li><li class="chapter-item "><div>Effect Sets and Aliases</div></li></ol></li><li class="chapter-item "><a href="../archive/index.html">üì¶ Archive</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust.html">Effects in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/async.html">Asynchrony</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/const.html">Compile-Time Execution</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/try.html">Fallibility</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/gen.html">Iteration</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/panic.html">Unwinding</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/unsafe.html">Memory-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/pin.html">Immovability</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/sized.html">Object-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/ownership.html">Ownership</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/send.html">Thread-Safety</a></li></ol></li><li class="chapter-item "><a href="../archive/evaluation/effect-hierarchy.html">Effect hierarchy</a></li><li class="chapter-item "><a href="../archive/evaluation/grouping-keyword-generics.html">Grouping keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/introducing-new-keyword-generics.html">Introducing new keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/mir-desugaring.html">MIR desugaring</a></li><li class="chapter-item "><a href="../archive/evaluation/overloading-keyword-generics.html">Overloading</a></li><li class="chapter-item "><a href="../archive/evaluation/prior-art.html">Prior Art</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">keyword generics initiative</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative/edit/master/./evaluation/auto-concurrency.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="auto-concurrency"><a class="header" href="#auto-concurrency">Auto Concurrency</a></h1>
<p>Async Rust brings <a href="https://blog.yoshuawuyts.com/why-async-rust/">three unique capabilities to
Rust</a>: the ability to apply ad-hoc
concurrency, the ability to arbitrarily pause, cancel and resume operations, and
finally the ability to combine these capabilities into new ones - such as ad-hoc
timeouts. Async Rust also does one other thing: it decouples &quot;concurrency&quot; from
&quot;parallelism&quot; - while in non-async Rust both are coupled into the &quot;thread&quot;
primitive.</p>
<p>One challenge however is to make use of these capabilities. People notoriously
struggle to use cancellation correctly, and are often caught off guard that
computations after being suspended at an <code>.await</code> point may not necessarily be
resumed (&quot;cancelled&quot;). Similarly: users will often struggle to apply
fine-grained concurrency in their applications - because it fundamentally means
exploding sequential control-flow sequences into Directed Acyclic control-flow
Graphs (control-flow DAGs).</p>
<h2 id="by-example-swift"><a class="header" href="#by-example-swift">By Example: Swift</a></h2>
<p>Swift has introduced the <code>async let</code> keyword to enable linear-looking
control-flow which statically expands to a concurrent DAG backed by tasks. To
see how this works we can reference
<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md">SE-0304</a>'s
example which provides a <code>makeDinner</code> routine:</p>
<pre><code class="language-swift">func makeDinner() async throws -&gt; Meal {
  async let veggies = chopVegetables()                    // 1. concurrent with: 2, 3
  async let meat = marinateMeat()                         // 2. concurrent with: 1, 3
  async let oven = preheatOven(temperature: 350)          // 3. concurrent with: 1, 2, 4

  let dish = Dish(ingredients: await [try veggies, meat]) // 4. depends on: 1, 2, concurrent with: 3
  return await oven.cook(dish, duration: .hours(3))       // 5. depends on: 3, 4, not concurrent
}
</code></pre>
<p>The following constraints and operations occur here:</p>
<ul>
<li>constraint: <code>dish</code> depends on <code>veggies</code> and <code>meat</code>.</li>
<li>concurrency: <code>veggies</code>, <code>meat</code>, and <code>oven</code> are computed concurrently</li>
<li>constraint: <code>Meal</code> depends on <code>oven</code> and <code>dish</code></li>
<li>concurrency: <code>oven</code> and <code>dish</code> are computed concurrently</li>
</ul>
<p>In Swift the <code>async let</code> syntax automatically spawns tasks and ensures that they
resolve when they need to. In Swift <code>await {}</code> and <code>try {}</code> apply not just to
the top-level expressions but also to all sub-expressions, so for example
awaiting the <code>oven</code> is handled by <code>await oven.cook (..)</code>. We can translate this
to Rust using the <a href="https://docs.rs/futures-concurrency"><code>futures-concurrency</code>
library</a> without having to use parallel
tasks - just concurrent futures. That would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures_concurrency::prelude::*;

async fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    let dish = {
        let veggies = chop_vegetables();
        let meat = marinate_meat();
        let (veggies, meat) = (veggies, meat).try_join().await?;
        Dish::new(&amp;[veggies, meat]).await
    };
    let (dish, oven) = (dish, preheat_oven(350)).try_join().await?;
    oven.cook(dish, Duration::from_mins(3 * 60)).await
}
<span class="boring">}
</span></code></pre></pre>
<p>Compared to Swift the control-flow here is much harder to tease apart. We've
accurately described our concurrency DAG; but reversing it to understand
<em>intent</em> has suddenly become a lot harder. Programmers generally have a better
time understanding code when it can be read sequentially; and so it's no
surprise that the Swift version is better at stating intent.</p>
<h2 id="auto-concurrency-for-rusts-async-effect-contexts"><a class="header" href="#auto-concurrency-for-rusts-async-effect-contexts">Auto-concurrency for Rust's Async Effect Contexts</a></h2>
<p>Rust's async system differs a little from Swift's, but only in the details. The
main differences as it comes to what we'd want to do here are three-fold:</p>
<ol>
<li>Swift's async primitive are tasks: which are managed, parallel async
primitives. In Rust it's <code>Future</code>, which is unmanaged and not parallel by
default - it's only concurrent.</li>
<li>In Rust all <code>.await</code> points have to be explicit and recursive awaiting of
expressions is not supported. This is because as mentioned earlier: functions
may permanently yield control flow at <code>.await</code> points, and so they have to be
called out in the source code.</li>
</ol>
<p>For these reasons we can't quite do what Swift does - but I believe we could
probably do something similar. From a language perspective, it seems like it
should be possible to do a similar system to <code>async let</code>. Any number of <code>async let</code> statements can be joined together by the compiler into a single
control-flow graph, as long as their outputs don't depend on each other. And if
we're calling <code>.await?</code> on <code>async let</code> statements we can even ensure to insert
calls to <code>try_join</code> so concurrently executing functions can early abort on
error.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    async let veggies = chop_vegetables();  // 1. concurrent with: 2, 3
    async let meat = marinate_meat();       // 2. concurrent with: 1, 3
    async let oven = preheat_oven(350);     // 3. concurrent with: 1, 2, 4

    async let dish = Dish(&amp;[veggies.await?, meat.await?]);   // 4. depends on: 1, 2, concurrent with: 3
    oven.cook(dish.await, Duration::from_mins(3 * 60)).await // 5. depends on: 3, 4, not concurrent
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, just like in the Swift example, we'd achieve concurrency between all
independent steps. And where steps are dependent on one another, they would be
computed as sequential. Each future still needs to be <code>.await</code>ed - but in order
to be evaluated concurrently the program authors no longer have to figure it out
by hand.</p>
<p>If we think about it, this feels like a natural evolution from the principles of
<code>async/.await</code>. Just the syntax alone provides us with the ability to convert
complex asynchronous callback graphs into seemingly imperative-looking code. And
by extending that to concurrency too, we're able to reap even more benefits from it.</p>
<h2 id="what-about-other-concurrency-operations"><a class="header" href="#what-about-other-concurrency-operations">What about other concurrency operations?</a></h2>
<p>A brief look at the <a href="https://docs.rs/futures-concurrency/latest/futures_concurrency/"><code>futures-concurrency</code>
library</a> will
reveal a number of concurrency operations. Yet here we're only discussing one:
<code>Join</code>. That is because all the other operations do something which is unique to
async code, and so we have to write async code to make full use of it. Whereas
<code>join</code> does not semantically change the code: it just takes independent
sequential operations and runs them in concert.</p>
<h2 id="maybe-async-and-auto-concurrency"><a class="header" href="#maybe-async-and-auto-concurrency">Maybe-async and auto-concurrency</a></h2>
<p>The main premise of <code>#[maybe(async)]</code> notations is that they can take sequential
code and optionally run them without blocking. Under the system described in
this post that code could not only be non-blocking, it could also be concurrent.
Taking the system we're describing in the &quot;Effect Generic Function Bodies and
Bounds&quot; draft, we could write our <code>async let</code>-based code example as follows to
make it conditional over the <code>async</code> effect:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]  // &lt;- changed `async fn` to `#[maybe(async)] fn`
fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    async let veggies = chop_vegetables();
    async let meat = marinate_meat();
    async let oven = preheat_oven(350);

    async let dish = Dish(&amp;[veggies.await?, meat.await?]);
    oven.cook(dish.await, Duration::from_mins(3 * 60)).await
}
<span class="boring">}
</span></code></pre></pre>
<p>Which when evaluated synchronously would be lowered to the following code. This
code blocks and runs sequentially, but that is the best we can do without async
Rust's ad-hoc async capabilities.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    let veggies = chop_vegetables();
    let meat = marinate_meat();
    let oven = preheat_oven(350);

    let dish = Dish(&amp;[veggies?, meat?]);
    oven.cook(dish, Duration::from_mins(3 * 60))
}
<span class="boring">}
</span></code></pre></pre>
<p>This is not the only way that <code>#[maybe(async)]</code> code could leverage async
concurrency operations: an async version of
<a href="https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html"><code>const_eval_select</code></a>
would also work. It would, however, be by far the most convenient way of
creating parity between both contexts. As well as make async Rust code that much
easier to read.</p>
<h2 id="a-note-on-syntax"><a class="header" href="#a-note-on-syntax">A note on syntax</a></h2>
<p>An earlier version of this document proposed using <code>.co.await</code>, <code>.co_await</code>,
just <code>.co</code> or some other keyword to take the place of <code>async let</code> to indicate a
concurrent <code>.await</code> can happen. The feasibility of syntax like that is not
clear; though there would likely be distinct benefits to preserving the postfix
nature of existing notations. Any further exploration of this direction should
consider alternate syntaxes to <code>async let</code>. In particular as concurrent
execution of <code>for await</code> loops is something that's also desirable, and would
likely want syntax parity with concurrent execution of futures.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this document we describe a mechanism inspired by Swift's <code>async let</code>
primitive to author imperative-looking code which is lowered into concurrent,
unmanaged futures. Rather than needing to manually convert linear code into a
concurrent directed graph, the compiler could do that for us. Here is an example
code as we would write it today using the
<a href="https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html"><code>Join::join</code></a>
operation, compared to a high-level <code>async let</code> based variant which would
desugar into the same code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A manual concurrent implementation using Rust 1.76 today.
async fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    let dish = {
        let veggies = chop_vegetables();
        let meat = marinate_meat();
        let (veggies, meat) = (veggies, meat).try_join().await?;
        Dish::new(&amp;[veggies, meat]).await
    };
    let (dish, oven) = (dish, preheat_oven(350)).try_join().await?;
    oven.cook(dish, Duration::from_mins(3 * 60)).await
}

/// An automatic concurrent implementation using a hypothetical `async let`
/// feature. This would desugar into equivalent code as the manual example.
async fn make_dinner() -&gt; SomeResult&lt;Meal&gt; {
    async let veggies = chop_vegetables();  // 1. concurrent with: 2, 3
    async let meat = marinate_meat();       // 2. concurrent with: 1, 3
    async let oven = preheat_oven(350);     // 3. concurrent with: 1, 2, 4

    async let dish = Dish(&amp;[veggies.await?, meat.await?]);   // 4. depends on: 1, 2, concurrent with: 3
    oven.cook(dish.await, Duration::from_mins(3 * 60)).await // 5. depends on: 3, 4, not concurrent
}
<span class="boring">}
</span></code></pre></pre>
<p>This is not the first proposal to suggest an some form of concurrent notation
for async Rust; to our knowledge that would be Conrad Ludgate in their <a href="https://conradludgate.com/posts/async-let">async
let blog post</a>. However just like in
Swift it seems to be based on the idea of managed multi-threaded tasks - not
Rust's unmanaged, lightweight futures primitive.</p>
<p>A version of this is likely possible for multi-threaded code too; ostensibly via
some kind of <code>par</code> keyword (<code>par let</code> / <code>par for await..in</code>). A full design is out
of scope for this post; but it should be possible to improve Rust's parallel
system in both async and non-async Rust alike (using tasks and threads
respectively).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://github.com/apple/swift-evolution/blob/main/proposals/0304-structured-concurrency.md">Swift SE-0304: Structured Concurrency</a></li>
<li><a href="https://conradludgate.com/posts/async-let">Conrad Ludgate: Async Let - A New Concurrency Primitive?</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../evaluation/pattern-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../explainer/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../evaluation/pattern-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../explainer/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
