<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pattern Types and Backwards Compatibility - keyword generics initiative</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../updates/index.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2022-07-27-announcing-the-keyword-generics-initiative.html">2022-07-27: Announcing the Keyword Generics Initiative</a></li><li class="chapter-item "><a href="../updates/2023-02-23-keyword-generics-progress-report-feb-2023.html">2023-02-23: Keyword Generics Progress Report February 2023</a></li><li class="chapter-item "><a href="../updates/2024-02-09-extending-rusts-effect-system.html">2024-02-09: Extending Rust's Effect System</a></li></ol></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item expanded "><a href="../evaluation/index.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/index.html">Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/_template.html">Template</a></li><li class="chapter-item "><a href="../evaluation/syntax/attributes.html">Attributes</a></li><li class="chapter-item "><a href="../evaluation/syntax/const-bool-like-effects.html">Const-bool like effects</a></li><li class="chapter-item "><a href="../evaluation/syntax/effect-as-a-clause.html">Effect as a clause</a></li><li class="chapter-item "><a href="../evaluation/syntax/postfix-question-mark.html">Postfix question mark</a></li><li class="chapter-item "><a href="../evaluation/syntax/where-effect-bounds.html">Where effect bounds</a></li></ol></li><li class="chapter-item expanded "><a href="../evaluation/pattern-types.html" class="active">Pattern Types and Backwards Compatibility</a></li><li class="chapter-item "><a href="../evaluation/auto-concurrency.html">Auto Concurrency</a></li></ol></li><li class="chapter-item "><a href="../explainer/index.html">üìö Draft RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/effect-generic-trait-declarations.html">Effect-Generic Trait Declarations</a></li><li class="chapter-item "><a href="../explainer/effect-generic-bounds-and-functions.html">Effect-Generic Bounds and Functions</a></li><li class="chapter-item "><div>Effect-Generic Types</div></li><li class="chapter-item "><div>Effect Sets and Aliases</div></li></ol></li><li class="chapter-item "><a href="../archive/index.html">üì¶ Archive</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust.html">Effects in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/async.html">Asynchrony</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/const.html">Compile-Time Execution</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/try.html">Fallibility</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/gen.html">Iteration</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/panic.html">Unwinding</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/unsafe.html">Memory-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/pin.html">Immovability</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/sized.html">Object-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/ownership.html">Ownership</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/send.html">Thread-Safety</a></li></ol></li><li class="chapter-item "><a href="../archive/evaluation/effect-hierarchy.html">Effect hierarchy</a></li><li class="chapter-item "><a href="../archive/evaluation/grouping-keyword-generics.html">Grouping keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/introducing-new-keyword-generics.html">Introducing new keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/mir-desugaring.html">MIR desugaring</a></li><li class="chapter-item "><a href="../archive/evaluation/overloading-keyword-generics.html">Overloading</a></li><li class="chapter-item "><a href="../archive/evaluation/prior-art.html">Prior Art</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">keyword generics initiative</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative/edit/master/./evaluation/pattern-types.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pattern-types-and-backwards-compatibility"><a class="header" href="#pattern-types-and-backwards-compatibility">Pattern Types and Backwards Compatibility</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><a href="https://gist.github.com/joboet/0cecbce925ee2ad1ee3e5520cec81e30">Pattern types</a>
are an in-progress proposal for Rust to add a limited form of refinement types /
liquid types to Rust via pattern the pattern notation. Take for example the
existing
<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.load"><code>AtomicBool::load</code></a>
operation. Its signature looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A boolean type which can be safely shared between threads.
struct AtomicBool { .. }

impl AtomicBool {
    /// Loads a value from the bool.
    pub fn load(&amp;self, order: Ordering) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>Atomics are part Rust's memory model, and are how we're able to share data
between threads. Depending on what we want to do with an atomic, we'll want to
give it a different
<a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>
argument. <code>Ordering</code> is just an enum, which has the following variants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
<span class="boring">}
</span></code></pre></pre>
<p>For this example it doesn't exactly matter what each of these variants are for.
But what's important is that not all variants are valid arguments for
<code>AtomicBool::load</code>. Its documentation says that <code>SeqCst</code>, <code>Acquire</code>, and
<code>Relaxed</code> are valid. But if the <code>Release</code> or <code>AcqRel</code> variants are used, it will
panic at runtime.</p>
<p>Pattern types would in theory enable us to &quot;shift-left&quot; on this, by encoding the
allowed variants directly into the function's parameters. This would encode this
invariant directly via the type system, meaning we've &quot;shifted left&quot; from a
runtime error (e.g. we need to run tests to find the bug), to a compiler error
(e.g. we need to run <code>cargo check</code> to find the bug). Using the pattern types
draft RFC, this would look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AtomicBool { .. }
impl AtomicBool {
    pub fn load(&amp;self,
        order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
    ) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="backwards-compatibility-issues"><a class="header" href="#backwards-compatibility-issues">Backwards-compatibility issues</a></h2>
<p>Moving checks from runtime to compile-time is generally considered a good thing,
as it shortens the time it takes to discover bugs. But when we use pattern types
as inputs to functions, we're <em>constraining</em> the input space from all variants
to just the legal variants. Take for example the following code, which is legal
to write today.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_wrapper(order: Ordering, bool: &amp;AtomicBool) -&gt; bool {
    bool.load(order)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code does not know about pattern types, and Rust's backwards-compatibility
guarantees require that it keeps compiling in future releases of the compiler.
That means that changing <code>AtomicBool::load</code> to require taking pattern types as
its input would be a backwards-incompatible change. So we cannot just do that.</p>
<p>One alternative would be to create a duplicate version of <code>AtomicBool</code> which
does know how to take pattern types. But duplicating code just to improve it
feels pretty bad - instead it would be nice if we could update existing
functions without it leading to breaking changes.</p>
<h2 id="resolving-the-backwards-compatibility-issues"><a class="header" href="#resolving-the-backwards-compatibility-issues">Resolving the backwards-compatibility issues</a></h2>
<p>On Zulip people have brought up the idea of using editions to resolve these
issues. That might be possible, but it would mean a clean break between code
written on an older edition, and code written on a newer edition. And while we
can leverage editions to change defaults in the language, this kind of break
feels like it would push against the intended goal of maintaining compatibility
between editions.</p>
<p>The idea underlying it seems right though: we do want some way to express
<em>modality</em> in our type system. We've already done this before using the <code>const</code>
effect. Functions tagged as <code>const</code> can be evaluated either during compilation
or at runtime. And it's backwards-compatible to take an existing runtime-only
<code>fn</code> and change it to a <code>const fn</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn meow() -&gt; &amp;'static str { &quot;meow&quot; }         // 1. The base `fn meow`
const fn meow() -&gt; &amp;'static str { &quot;meow&quot; }   // 2. Changing `meow` to a `const fn` is backwards-compatible
<span class="boring">}
</span></code></pre></pre>
<p>We could do something very similar with pattern types as well. The base
mechanism for this is to define a function which can be compiled in one of two
modes:</p>
<ol>
<li><strong>Invariants are evaluated at compile-time</strong>: The pattern types are evaluated by
the compiler according to the pattern type RFC. A compiler error is raised if
the pattern's invariants are violated.</li>
<li><strong>Invariants are evaluated at runtime</strong>: The pattern types are converted to a
sequence of assertions, and evaluated at runtime.</li>
</ol>
<p>The translation here from pattern types to runtime assertions should be fairly
mechanical. We could imagine some notation which signals that while a function
may declare pattern types, the caller has an option to either evaluate them at
runtime or during compilation. Taking our earlier <code>AtomicBool::load</code> example, we
could imagine something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AtomicBool { .. }
impl AtomicBool {
    #[maybe(pattern_types)]
    pub fn load(&amp;self,
        order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
    ) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>With this notation, all existing uses of <code>AtomicBool::load</code> would continue
working. But optionally it could be called using pattern types, which would be
evaluated at compile-time. Depending on which variant of the function is
selected, the lowering of the function would change. Desugared, this would
roughly look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Semantic lowering of `AtomicBool::load`
/// using compile-time checks
pub fn load(&amp;self,
    order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
) -&gt; bool { .. }

/// Semantic lowering of `AtomicBool::load`
/// using runtime assertions
pub fn load(&amp;self, order: Ordering) -&gt; bool {
    match order {
        order @ Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed =&gt; ..,
        order =&gt; panic!(&quot;Expected `Ordering::{{Acquire | Relaxed | SeqCst}}`, received {order}&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="todo-effect-logic-and-notation"><a class="header" href="#todo-effect-logic-and-notation">TODO: Effect logic and notation</a></h2>
<ul>
<li>in its base there are four states possible: <code>always | never | maybe | unknown</code></li>
<li><code>maybe(pattern_types)</code> is a backwards-compatibility guarantee. Having logical <code>never</code>
<ul>
<li><code>always</code> markers will put us in a position where we can eventually pull the
lever across an edition to default all functions to default to always using
pattern types - without breaking any existing code or breaking code compat.</li>
</ul>
</li>
<li>unlike <code>maybe(async)</code>, by lowering to runtime checks functions which use
<code>maybe</code> patterns should always be able to call functions which take <code>always</code>
patterns - runtime assertions using <code>match</code> will be enough to shrink
the input state to be valid from that point onward</li>
<li>the relation to subtyping and return types will affect which states of this system we may want to encode</li>
<li>unclear what the benefits are for a strictly &quot;always subtyping&quot; notation</li>
<li>in practice we'll want to independently gate the stabilization of pattern
types for existing stdlib APIs - which means we need a labeling system in the compiler</li>
</ul>
<h2 id="example-how-to-combine-effect-states-for-pattern-types"><a class="header" href="#example-how-to-combine-effect-states-for-pattern-types">Example: how to combine effect states for pattern types</a></h2>
<p><a href="https://github.com/Nadrieril">Nadrieril</a> asked the following question:</p>
<blockquote>
<p>Consider the case where crate A uses compile-time checks for pattern types and
crate B uses crate A but has no knowledge of pattern types. If we encode this
choice as an effect, we must be careful not to bubble it up (as effects do) to a
function that has no knowledge of pattern types.</p>
</blockquote>
<p>Let's write this example out. We're going to write three functions: one which
always uses pattern types, one which may use pattern types, and a function which
doesn't use pattern types. They all call each other, and that should Just Work.
Let's start with the always-pattern function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function always evaluates pattern
/// types at compile-time.
fn always(num: u8 is 0..10) {
    println!(&quot;received number {num}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>There's nothing too special about this function: it always takes a pattern type,
meaning we can't just give it any <code>u8</code> - it needs to fit the pattern. Next,
let's write out a maybe-pattern function which either takes a pattern or a base
type - and depending on which variant is passed will either validate the input
during compilation or at runtime. This will then call into our <code>always</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function can evaluate pattern types
/// either at compile-time or at runtime
#[maybe(pattern_types)]
fn maybe(num: u8 is 0..10) {
    always(num);
}
<span class="boring">}
</span></code></pre></pre>
<p>This function either evaluates patterns during compilation or at runtime. As
we've seen before: if a pattern is evaluated at runtime, it will effectively
work as a <code>match</code> + <code>panic!</code>. As a result this function guarantees it will
<em>always</em> validate its inputs, meaning once we gain access to <code>num</code> in the
function body it will always conform to the pattern. And so we have no problem
calling the <code>always</code> function.</p>
<p>Next up is our function <code>never</code>, which never evaluates patterns. It takes a bare
<code>u8</code> with no restrictions on it whatsoever. It should be able to call the
<code>maybe</code> function without an issue.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function does not reason about pattern types
fn never(num: u8) {
    maybe(num);
}
<span class="boring">}
</span></code></pre></pre>
<p>But if we try calling the <code>always</code> function from <code>never</code>, we run into issues:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function does not reason about pattern types
fn never(num: u8) {
    always(num);  // ‚ùå compiler error
}
<span class="boring">}
</span></code></pre></pre>
<p>This should result in a compiler error along these lines:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/lib.rs:4:12
  |
4 |     always(num);
  |     ------ ^^^^^ expected `u8 is 0..10`, found `u8`
  |     |
  |     arguments to this function are incorrect
</code></pre>
<p>The easiest way to resolve this would be to rewrite the <code>never</code> function to take
the same signature as the <code>maybe</code> function. This would insert the correct
runtime checks, contraining the value to the right pattern, which as we've seen
would make it possible to call the <code>always</code> function without any issues.</p>
<h2 id="how-widespread-is-this"><a class="header" href="#how-widespread-is-this">How widespread is this?</a></h2>
<p>Maintaining strict backwards-compatibility is primarily a concern for the Rust
stdlib. While it might be difficult to create major versions for certain other
codebases, the Rust stdlib is in the unique position that it is both used by
everyone, and we can never break existing APIs. So when we're looking at using
pattern types in input positions, it's okay to assume the Rust stdlib will be
the main user of it. To date we know of at least the following APIs which would
want to leverage pattern types as inputs:</p>
<ul>
<li><strong>number primitives</strong>: Number types in Rust expose a wide range of operations.
Take for example a look at the <a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code>
type</a>. It exposes around 20
operations per type which will panic if certain number ranges are passed.</li>
<li><strong>atomics</strong>: this is the example we've been using in this post. Atomic
operations take an <code>Ordering</code> enum, where each operation can only take certain
variants of that enum. Being able to check that during compilation would be a
boon.</li>
<li><strong>iterator methods</strong>: For example
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by"><code>Iterator::step_by</code></a>
currently takes a <code>usize</code>, but would want to take a <code>usize is 1..</code>. The same is
true for the unstable <code>Iterator::array_chunks</code> and <code>Iterator::map_windows</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../evaluation/syntax/where-effect-bounds.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../evaluation/auto-concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../evaluation/syntax/where-effect-bounds.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../evaluation/auto-concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
