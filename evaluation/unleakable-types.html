<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unleakable Types - keyword generics initiative</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../updates/index.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2022-07-27-announcing-the-keyword-generics-initiative.html">2022-07-27: Announcing the Keyword Generics Initiative</a></li><li class="chapter-item "><a href="../updates/2023-02-23-keyword-generics-progress-report-feb-2023.html">2023-02-23: Keyword Generics Progress Report February 2023</a></li><li class="chapter-item "><a href="../updates/2024-02-09-extending-rusts-effect-system.html">2024-02-09: Extending Rust's Effect System</a></li></ol></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item expanded "><a href="../evaluation/index.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/index.html">Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/syntax/_template.html">Template</a></li><li class="chapter-item "><a href="../evaluation/syntax/attributes.html">Attributes</a></li><li class="chapter-item "><a href="../evaluation/syntax/const-bool-like-effects.html">Const-bool like effects</a></li><li class="chapter-item "><a href="../evaluation/syntax/effect-as-a-clause.html">Effect as a clause</a></li><li class="chapter-item "><a href="../evaluation/syntax/postfix-question-mark.html">Postfix question mark</a></li><li class="chapter-item "><a href="../evaluation/syntax/where-effect-bounds.html">Where effect bounds</a></li></ol></li><li class="chapter-item "><a href="../evaluation/pattern-types.html">Pattern Types and Backwards Compatibility</a></li><li class="chapter-item "><a href="../evaluation/auto-concurrency.html">Auto Concurrency</a></li><li class="chapter-item expanded "><a href="../evaluation/unleakable-types.html" class="active">Unleakable Types</a></li></ol></li><li class="chapter-item "><a href="../explainer/index.html">üìö Draft RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/effect-generic-trait-declarations.html">Effect-Generic Trait Declarations</a></li><li class="chapter-item "><a href="../explainer/effect-generic-bounds-and-functions.html">Effect-Generic Bounds and Functions</a></li><li class="chapter-item "><div>Effect-Generic Types</div></li><li class="chapter-item "><div>Effect Sets and Aliases</div></li></ol></li><li class="chapter-item "><a href="../archive/index.html">üì¶ Archive</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust.html">Effects in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/async.html">Asynchrony</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/const.html">Compile-Time Execution</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/try.html">Fallibility</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/gen.html">Iteration</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/panic.html">Unwinding</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/unsafe.html">Memory-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/pin.html">Immovability</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/sized.html">Object-Safety</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/ownership.html">Ownership</a></li><li class="chapter-item "><a href="../archive/evaluation/effects-in-rust/send.html">Thread-Safety</a></li></ol></li><li class="chapter-item "><a href="../archive/evaluation/effect-hierarchy.html">Effect hierarchy</a></li><li class="chapter-item "><a href="../archive/evaluation/grouping-keyword-generics.html">Grouping keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/introducing-new-keyword-generics.html">Introducing new keyword generics</a></li><li class="chapter-item "><a href="../archive/evaluation/mir-desugaring.html">MIR desugaring</a></li><li class="chapter-item "><a href="../archive/evaluation/overloading-keyword-generics.html">Overloading</a></li><li class="chapter-item "><a href="../archive/evaluation/prior-art.html">Prior Art</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">keyword generics initiative</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative/edit/master/./evaluation/unleakable-types.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unleakable-types"><a class="header" href="#unleakable-types">Unleakable Types</a></h1>
<h2 id="a-trait-based-system-for-unleakable-types"><a class="header" href="#a-trait-based-system-for-unleakable-types">A trait-based system for unleakable types</a></h2>
<p>In the <a href="https://blog.yoshuawuyts.com/linear-types-one-pager/">Linear Types
One-Pager</a> post Yosh
presented a system for types which cannot be leaked. This showed how by
introducing a new auto-trait <code>Leak</code>, we could construct a system that would
prevent types from being leaked.</p>
<p>By preventing types from being leaked, destructors would be guaranteed to run -
which would give allow types in Rust to uphold linear type invariants. Meaning:
destructors could be relied on for the purposes of safety, because some code
will always be run when a type goes out of scope.</p>
<p>The way to think about this system is as follows:</p>
<ol>
<li>We define a new unsafe auto-trait named <code>Leak</code></li>
<li>All bounds take an implicit + Leak bound, like we do for <code>+ Sized</code>.</li>
<li>Certain functions such as <code>mem::forget</code> will always keep taking <code>+ Leak</code> bounds.</li>
<li>Functions which want to opt-in to linearity can take <code>+ ?Leak</code> bounds.</li>
<li>Types which want to opt-in to linearity can implement <code>!Leak</code> or put a <code>PhantomLeak</code> type in a field.</li>
</ol>
<p>In code we could see this system expressed as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the trait and create a blanket impl for all types.
// The language would automatically add `+ Leak` bounds to all bounds.
auto trait Leak;
impl&lt;T&gt; Leak for T {}

// Types are by default assumed to be leakable.
struct Leakable;

// Mark a type as unleakable, guaranteeing destructors are run
struct Unleakable;
impl !Leak for Unleakable {}

// A function which requires types implement `Leak`.
// Here `T: Leak` bounds would be assumed by default.
fn will_leak&lt;T&gt;(value: T) {..}

// A function which operates on types which may or may not leak.
// We're using `?Leak` to opt-out of the automatic `+ Leak` bound.
fn may_leak&lt;T: ?Leak&gt;(value: T) -&gt; T {..}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-limitation-of-auto-traits"><a class="header" href="#the-limitation-of-auto-traits">The limitation of auto-traits</a></h2>
<p>In the challenges section of <a href="https://blog.yoshuawuyts.com/linear-types-one-pager/">Linear Types
One-Pager</a> post, Yosh
remarks the following:</p>
<blockquote>
<p>We should look at an alternate formulation of these bounds by treating them
as built-in effects. That would allow us to address the issues of versioning,
visual noise, etc. in a more consistent and ergonomic way. But that's not a
requirement to start testing this out.</p>
</blockquote>
<p>The limitations of auto-traits are well-documented, and nobody would be excited
by the prospect of introducing <code>+ ?Leak</code> bounds to virtually every bound. For
that reason there was a recommendation to explore alternate effect-based
formulations instead.</p>
<p>A concrete example of a limitation for <code>Leak</code> as an auto-trait is provided by
Saoirse in their posts &quot;Changing the rules of Rust&quot;, &quot;Follow up to &quot;Changing
the rules of Rust&quot;, and &quot;Generic trait methods and new auto traits&quot;. They
provide an example equivalent to the following:</p>
<pre><pre class="playground"><code class="language-rust">#[edition = 2027]
crate may_leak {
    #[leak_compatible]  // ‚Üê allows bounds to optionally add `+ Leak`
    pub trait MayLeak {
        fn may_leak&lt;T&gt;(input: T);
    }
}

#[edition = 2024]
crate will_leak {
    pub struct WillLeak;
    impl super::may_leak::MayLeak for WillLeak {
        fn may_leak&lt;T&gt;(input: T) { // ‚Üê takes an implicit `+ Leak` bound
            core::mem::forget(input);
        }
    }
}

#[edition = 2027]
crate may_not_leak {
    struct Unleakable;
    impl !Leak for Unleakable {}
    pub fn may_not_leak&lt;T: #[no_leak] super::may_leak::MayLeak&gt;() { // ‚Üê disables the optional `+ Leak` bound
        T::may_leak(Unleakable);
    }
}

// The edition doesn't matter for this function.
fn main() {
    may_not_leak::may_not_leak::&lt;will_leak::WillLeak&gt;();
}
</code></pre></pre>
<p>Under the rules we provided earlier, when we pass <code>WillLeak</code> to <code>may_not_leak</code>
it should yield a compile-error. This ends up trying to pass a type which is
<code>!Leak</code> to a function which takes an implicit <code>+ Leak</code> bound, which shouldn't
compile.</p>
<p>The limitations of this approach very clearly show up once we consider how this
would be rolled out in practice. Every API which would want to types optionally
leaking would need to add a <code>+ ?Leak</code> or <code>#[maybe(leak)]</code> annotation to every
parameter which may ever want to leak. This system mixes bespoke attributes
together with auto-traits to create a system very similar to that of <code>const</code>.</p>
<h2 id="reformulating-leaking-as-an-effect"><a class="header" href="#reformulating-leaking-as-an-effect">Reformulating leaking as an effect</a></h2>
<p>The system of <code>#[leak_compatible]</code> and <code>#[no_leak]</code> annotations presented is a
bespoke encoding of the general system covered by effect generics. Fundamentally
both effects and trait bounds can be in one of three states:</p>
<ul>
<li><strong>required</strong>: covered earlier by the implicit <code>+ Leak</code> bound, and by <code>effect T</code> under effect generics.</li>
<li><strong>optional</strong>: covered earlier by the <code>#[leak_compatible]</code> annotation, and <code>#[maybe(effect)]</code> under effect generics.</li>
<li><strong>absent</strong>: covered by the earlier <code>#[no_leak]</code> annotation, and <code>#[no(effect)]</code> under effect-generics.</li>
</ul>
<p>When discussing effects, they can either be opt-in (e.g. <code>async</code>, <code>try</code>) where
we assume capabilities are not present unless we state we want them. Or opt-out
(e.g. <code>const</code>) where we assume capabilities are present, and we opt-out of them
go gain some other property. Currently Rust code may always leak, and what we're
taking away is the ability to leak. Likely the right approach here would be to
name the effect <code>leak</code>, and allow people to write both <code>leak T</code> and <code>#[no(leak)] T</code>. Under these rules the system would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mark a type as unleakable, guaranteeing destructors are run
#[not(leak)]
struct Unleakable;

// A type which may be leaked. `leak struct` is assumed,
// but can be written out for clarity.
struct Leakable;
leak struct Leakable;

// A function which requires all arguments can be leaked.
// `leak fn` is assumed by default, but may be written out for clarity.
fn will_leak&lt;T&gt;(value: T) {..}
leak fn will_leak&lt;T&gt;(value: T) {..}

// A function which operates on types which may or may not leak.
#[maybe(leak)]
fn may_leak&lt;T&gt;(value: T) -&gt; T {..}
<span class="boring">}
</span></code></pre></pre>
<p>Applying this sytem to the longer example would look like this:</p>
<pre><pre class="playground"><code class="language-rust">#[edition = 2027]
crate may_leak {
    #[maybe(leak)] // ‚Üê indicates this trait may of may not leak
    pub trait MayLeak {
        fn may_leak&lt;#[maybe(leak)] T&gt;(input: T); // ‚Üê indicates the type in this bound may or may not leak
    }
}

#[edition = 2024]
crate will_leak {
    pub struct WillLeak;
    impl super::may_leak::MayLeak for WillLeak {
        fn may_leak&lt;T&gt;(input: T) { // ‚Üê is assumed to be a `leak fn`; assumes `leak T`
            core::mem::forget(input);
        }
    }
}

#[edition = 2027]
crate may_not_leak {
    #[not(leak)] // ‚Üê this type may not be leaked
    struct Unleakable;

    #[not(leak)] // ‚Üê states all bounds take `#[no(leak)]`
    pub fn may_not_leak&lt;T: super::may_leak::MayLeak&gt;() {
        T::may_leak(Unleakable);
    }
}

// The edition doesn't matter for this function.
fn main() {
    may_not_leak::may_not_leak::&lt;will_leak::WillLeak&gt;();
}
</code></pre></pre>
<p>While similar to the previous design, this version applies a consistent logic
and naming to the bounds and ascriptions following the system laid out by
effect-generics. This would make it so introducing linearity into the type
system wouldn't be its own design with its own attributes, but part of a
consistent framework by which we can evolve the language.</p>
<h2 id="changing-defaults-across-editions"><a class="header" href="#changing-defaults-across-editions">Changing defaults across editions</a></h2>
<p>An alternative design for <code>#[not(leak)]</code> would be to follow the design of the
const keyword more closely, and introduce a positive effect. Perhaps something
like a <code>linear T</code> / <code>linear fn</code>. However if we assume we will eventually be
successful in the transition to adoption linearity, this would put us in the
awkward position where the ideal system would end up with more ascriptions.</p>
<p>The beauty of <code>#[not(leak)]</code> as the discriminant for linearity is that we could
eventually change the default across editions to not assume leaking is provided, and only if you
want to opt-in to being able to leak you have to add it to your functions. This
is currently already the same for keywords such as <code>async</code> and <code>gen</code>. Under
these rules, code would be able to change like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All types are assumed to be unleakable by default
struct Unleakable;

// A type which may be leaked.
leak struct Leakable;

// A function which requires all types can be leaked.
leak fn will_leak&lt;T&gt;(value: T) {..}

// A function which operates on types which may or may not leak.
fn may_leak&lt;T&gt;(value: T) -&gt; T {..}
<span class="boring">}
</span></code></pre></pre>
<p>Hypothetically a third kind of function could be described where all arguments
are assumed not to leak. But just like we don't (yet?) have a clear use case for
const-only functions, it's unclear that no-leak-only functions would be
beneficial. That said, effect generic provides a consistent framework which
would enable for these to be introduced.</p>
<h2 id="on-the-choice-of-keywords"><a class="header" href="#on-the-choice-of-keywords">On the choice of keywords</a></h2>
<p>All keywords and syntax used in this post should be interpreted as placeholders
only. It's hard to show examples if you don't name things, so we've picked some
names to make the example easier to follow. The emphasis of this post is on the
semantics of the system and showing how we can express linear types in a
consistent way by leveraging the framework of effect generics.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://faultlore.com/blah/linear-rust/">The pain of Real Linear Types in Rust</a></li>
<li><a href="https://smallcultfollowing.com/babysteps/blog/2023/03/16/must-move-types/">Must move types</a></li>
<li><a href="https://blog.yoshuawuyts.com/linearity-and-control/">Linearity and Control</a></li>
<li><a href="https://blog.yoshuawuyts.com/linear-types-one-pager/">Linear Types One-Pager</a></li>
<li><a href="https://sabrinajewson.org/blog/async-drop">Async destructors, async genericity and completion futures</a></li>
<li><a href="https://without.boats/blog/changing-the-rules-of-rust/">Changing the Rules of Rust</a></li>
<li><a href="https://without.boats/blog/follow-up-to-changing-the-rules-of-rust/">Follow up to &quot;Changing the rules of Rust&quot;</a></li>
<li><a href="https://without.boats/blog/generic-trait-methods-and-new-auto-traits/">Generic trait methods and new auto traits</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../evaluation/auto-concurrency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../explainer/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../evaluation/auto-concurrency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../explainer/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
