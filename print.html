<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>keyword generics initiative</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="updates/index.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="updates/2022-07-27-announcing-the-keyword-generics-initiative.html">2022-07-27: Announcing the Keyword Generics Initiative</a></li><li class="chapter-item "><a href="updates/2023-02-23-keyword-generics-progress-report-feb-2023.html">2023-02-23: Keyword Generics Progress Report February 2023</a></li><li class="chapter-item "><a href="updates/2024-02-09-extending-rusts-effect-system.html">2024-02-09: Extending Rust's Effect System</a></li></ol></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="evaluation/index.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/syntax/index.html">Syntax</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="evaluation/syntax/_template.html">Template</a></li><li class="chapter-item "><a href="evaluation/syntax/attributes.html">Attributes</a></li><li class="chapter-item "><a href="evaluation/syntax/const-bool-like-effects.html">Const-bool like effects</a></li><li class="chapter-item "><a href="evaluation/syntax/effect-as-a-clause.html">Effect as a clause</a></li><li class="chapter-item "><a href="evaluation/syntax/postfix-question-mark.html">Postfix question mark</a></li><li class="chapter-item "><a href="evaluation/syntax/where-effect-bounds.html">Where effect bounds</a></li></ol></li><li class="chapter-item "><a href="evaluation/pattern-types.html">Pattern Types and Backwards Compatibility</a></li></ol></li><li class="chapter-item "><a href="explainer/index.html">üìö Draft RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/effect-generic-trait-declarations.html">Effect-Generic Trait Declarations</a></li><li class="chapter-item "><a href="explainer/effect-generic-bounds-and-functions.html">Effect-Generic Bounds and Functions</a></li><li class="chapter-item "><div>Effect-Generic Types</div></li><li class="chapter-item "><div>Effect Sets and Aliases</div></li></ol></li><li class="chapter-item "><a href="archive/index.html">üì¶ Archive</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="archive/evaluation/effects-in-rust.html">Effects in Rust</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/async.html">Asynchrony</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/const.html">Compile-Time Execution</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/try.html">Fallibility</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/gen.html">Iteration</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/panic.html">Unwinding</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/unsafe.html">Memory-Safety</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/pin.html">Immovability</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/sized.html">Object-Safety</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/ownership.html">Ownership</a></li><li class="chapter-item "><a href="archive/evaluation/effects-in-rust/send.html">Thread-Safety</a></li></ol></li><li class="chapter-item "><a href="archive/evaluation/effect-hierarchy.html">Effect hierarchy</a></li><li class="chapter-item "><a href="archive/evaluation/grouping-keyword-generics.html">Grouping keyword generics</a></li><li class="chapter-item "><a href="archive/evaluation/introducing-new-keyword-generics.html">Introducing new keyword generics</a></li><li class="chapter-item "><a href="archive/evaluation/mir-desugaring.html">MIR desugaring</a></li><li class="chapter-item "><a href="archive/evaluation/overloading-keyword-generics.html">Overloading</a></li><li class="chapter-item "><a href="archive/evaluation/prior-art.html">Prior Art</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">keyword generics initiative</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/yoshuawuyts/keyword-generics-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="keyword-generics-initiative"><a class="header" href="#keyword-generics-initiative">keyword generics initiative</a></h1>
<!--

 This is the template for creating an initiative in rust-lang. Be sure to go
 through all sections marked with `**FIX ME**`, and make sure that the text is
 correct, and feel free to replace/remove any part that's not relevant to
 your group.

 Steps to customize:

 * Edit CHARTER.md
 * Replace placeholder text (see below)
 * Remove references to "expermental" and "evaluation" unless you need them
 
  All of the text across all of the initial files uses the same group of
 variables to allow for easy search and replace. They are listed below.

 Example sed command: `sed -i '' 's/keyword generics/Inline ASM/g' ./**/*.md`
 *Note* you need `-i ''` on macOS and just `-i` on Linux.

 * keyword generics -> The display name of your group e.g. "Inline ASM".
 * keyword-generics-initiative -> The url slug name of your group used for
   `rust-lang/team` and repo name. e.g. "pg-inline-asm".
 * Zulip -> The name of your chat app e.g. "Zulip".
 * {{CHAT_LINK}} -> The hyperlink to your discussions on the chat app
   e.g. "https://rust-lang.zulipchat.com/#narrow/stream/216763-project-inline-asm".

To get your repo under rust-lang, file an infra issue:
https://github.com/rust-lang/infra-team/issues/new

-->
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the keyword generics <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more
about what we are trying to do, and to find out the people who are doing it,
take a look at the <a href="./CHARTER.html">charter</a>. </p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>The following table lists of the stages of an initiative, along with links to the artifacts that will be produced during that stage.</p>
<table><thead><tr><th>Stage</th><th>State</th><th>Artifact(s)</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td><td>‚úÖ</td><td><a href="https://github.com/rust-lang/lang-team/issues/162">Proposal issue</a></td></tr>
<tr><td></td><td>‚úÖ</td><td><a href="./CHARTER.html">Charter</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td><td>‚úÖ</td><td><a href="./evaluation/">Evaluation</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td><td>ü¶Ä</td><td><a href="./explainer/">Draft RFCs</a></td></tr>
<tr><td></td><td>ü¶Ä</td><td><a href="https://github.com/rust-lang/rust/">Tracking issue</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature-complete.html">Feature complete</a></td><td>üí§</td><td>Stabilization report</td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td><td>üí§</td><td></td></tr>
</tbody></table>
<p>Key:</p>
<ul>
<li>‚úÖ -- phase complete</li>
<li>ü¶Ä -- phase in progress</li>
<li>üí§ -- phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for 'help wanted' issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-questions/README.html">design questions</a> first. </li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-questions/README.html">design-questions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/328082-t-lang.2Fkeyword-generics">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<p>To add a new update:</p>
<ul>
<li>Create a new file <code>updates/YYYY-mmm.md</code>, e.g. <code>updates/2021-nov.md</code>
<ul>
<li>We recomend basing this on the <a href="https://github.com/rust-lang/initiative-template/tree/master/updates/template.md">update template</a></li>
</ul>
</li>
<li>Link it from the <code>SUMMARY.md</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="announcing-the-keyword-generics-initiative"><a class="header" href="#announcing-the-keyword-generics-initiative">Announcing the Keyword Generics Initiative&quot;</a></h1>
<p><em>This post was originally posted on the <a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">Inside Rust
Blog</a>,
but is included in this repository to be more easily referenced.</em></p>
<p>We (<a href="https://github.com/oli-obk">Oli</a>, <a href="https://github.com/nikomatsakis">Niko</a>, and <a href="https://github.com/yoshuawuyts">Yosh</a>) are excited to announce the start of the <a href="https://github.com/rust-lang/keyword-generics-initiative">Keyword
Generics Initiative</a>, a new initiative <sup class="footnote-reference"><a href="#initiative">1</a></sup> under the purview of
the language team. We're officially just a few weeks old now, and in this post
we want to briefly share why we've started this initiative, and share some
insight on what we're about.</p>
<div class="footnote-definition" id="initiative"><sup class="footnote-definition-label">1</sup>
<p>Rust governance terminology can sometimes get confusing. An
&quot;initiative&quot; in Rust parlance is different from a &quot;working group&quot; or &quot;team&quot;.
Initiatives are intentionally limited: they exist to explore, design, and
implement specific pieces of work - and once that work comes to a close, the
initiative will wind back down. This is different from, say, the lang team -
which essentially carries a <code>'static</code> lifetime - and whose work does
not have a clearly defined end.</p>
</div>
<h2 id="a-missing-kind-of-generic"><a class="header" href="#a-missing-kind-of-generic">A missing kind of generic</a></h2>
<p>One of Rust's defining features is the ability to write functions which are
<em>generic</em> over their input types. That allows us to write a function once,
leaving it up to the compiler to generate the right implementations for us.</p>
<p>Rust allows you to be generic over types - it does not allow you to be generic
over other things that are usually specified by keywords. For example, whether a
function is async, whether a function can fail or not, whether a function is
const or not, etc.</p>
<p>The post <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">&quot;What color is your function&quot;</a> <sup class="footnote-reference"><a href="#color">2</a></sup> describes what happens
when a language introduces async functions, but with no way to be generic over
them:</p>
<blockquote>
<p>I will take async-await over bare callbacks or futures any day of the week.
But we‚Äôre lying to ourselves if we think all of our troubles are gone. As soon
as you start trying to write higher-order functions, or reuse code, you‚Äôre
right back to realizing color is still there, bleeding all over your codebase.</p>
</blockquote>
<p>This isn't just limited to async though, it applies to all modifier keywords -
including ones we may define in the future. So we're looking to fill that gap
by exploring something we call &quot;keyword generics&quot; <sup class="footnote-reference"><a href="#name">3</a></sup>: the ability to be
generic over keywords such as <code>const</code> and <code>async</code>.</p>
<div class="footnote-definition" id="color"><sup class="footnote-definition-label">2</sup>
<p>R. Nystrom, ‚ÄúWhat Color is Your Function?,‚Äù Feb. 01, 2015.
https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/
(accessed Apr. 06, 2022).</p>
</div>
<div class="footnote-definition" id="name"><sup class="footnote-definition-label">3</sup>
<p>The longer, more specific name would be: &quot;keyword modifier generics&quot;.
We've tried calling it that, but it's a bit of a mouthful. So we're just
sticking with &quot;keyword generics&quot; for now, even if the name for this feature may
end up being called something more specific in the reference and documentation.</p>
</div>
<p>To give you a quick taste of what we're working on, this is roughly how we
imagine you may be able to write a function which is generic over &quot;asyncness&quot;
in the future:</p>
<blockquote>
<p>Please note that this syntax is entirely made up, just so we can use something
in examples. Before we can work on syntax we need to finalize the semantics,
and we're not there yet. This means the syntax will likely be subject to
change over time.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async&lt;A&gt; trait Read {
    async&lt;A&gt; fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    async&lt;A&gt; fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { ... }
}

/// Read from a reader into a string.
async&lt;A&gt; fn read_to_string(reader: &amp;mut impl Read * A) -&gt; std::io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string).await?;
    string
}
<span class="boring">}
</span></code></pre></pre>
<p>This function introduces a &quot;keyword generic&quot; parameter into the function of <code>A</code>.
You can think of this as a flag which indicates whether the function is being
compiled in an async context or not. The parameter <code>A</code> is forwarded to the <code>impl Read</code>, making that conditional on &quot;asyncness&quot; as well.</p>
<p>In the function body you can see a <code>.await</code> call. Because <a href="https://blog.yoshuawuyts.com/async-cancellation-1/">the <code>.await</code> keyword
marks cancellation sites</a> we unfortunately can't just infer them
<sup class="footnote-reference"><a href="#cancellation">4</a></sup>. Instead we require them to be written for when the code is
compiled in async mode, but are essentially reduced to a no-op in non-async
mode.</p>
<div class="footnote-definition" id="cancellation"><sup class="footnote-definition-label">4</sup>
<p>No really, we can't just infer them - and it may not be as
simple as omitting all <code>.await</code> calls either. The Async WG is working through
the full spectrum of cancellation sites, async drop, and more. But for now we're
working under the assumption that <code>.await</code> will remain relevant going forward.
And even in the off chance that it isn't, fallibility has similar requirements
at the call site as async does.</p>
</div>
<p>We still have lots of details left to figure out, but we hope this at least
shows the general <em>feel</em> of what we're going for.</p>
<h2 id="a-peek-at-the-past-horrors-before-const"><a class="header" href="#a-peek-at-the-past-horrors-before-const">A peek at the past: horrors before const</a></h2>
<p>Rust didn't always have <code>const fn</code> as part of the language. A long long long long
long time ago (2018) we had to write a regular function for runtime computations
and associated const of generic type logic for compile-time computations. As an
example, to add the number <code>1</code> to a constant provided to you, you had to write
(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=50e818b79b8af322ed4384d3c33e9773">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Const&lt;T&gt; {
    const VAL: T;
}

/// `42` as a &quot;const&quot; (type) generic:
struct FourtyTwo;
impl Const&lt;i32&gt; for FourtyTwo {
    const VAL: i32 = 42;
}

/// `C` -&gt; `C + 1` operation:
struct AddOne&lt;C: Const&lt;i32&gt;&gt;(C);
impl&lt;C: Const&lt;i32&gt;&gt; Const&lt;i32&gt; for AddOne&lt;C&gt; {
    const VAL: i32 = C::VAL + 1;
}

AddOne::&lt;FourtyTwo&gt;::VAL
<span class="boring">}
</span></code></pre></pre>
<p>Today this is as easy as writing a <code>const fn</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn add_one(i: i32) -&gt; i32 {
    i + 1
}

add_one(42)
<span class="boring">}
</span></code></pre></pre>
<p>The interesting part here is that you can also just call this function in
runtime code, which means the implementation is shared between both <code>const</code>
(CTFE<sup class="footnote-reference"><a href="#ctfe">5</a></sup>) and non-<code>const</code> (runtime) contexts.</p>
<div class="footnote-definition" id="ctfe"><sup class="footnote-definition-label">5</sup>
<p>CTFE stands for &quot;Compile Time Function Execution&quot;: <code>const</code> functions
can be evaluated during compilation, which is implemented using a Rust
interpreter (miri).</p>
</div>
<h2 id="memories-of-the-present-async-today"><a class="header" href="#memories-of-the-present-async-today">Memories of the present: async today</a></h2>
<p>People write duplicate code for async/non-async with the only difference being
the <code>async</code> keyword. A good example of that code today is <a href="https://docs.rs/async-std/latest/async_std/"><code>async-std</code></a>, which
duplicates and translates a large part of the stdlib's API surface to be async
<sup class="footnote-reference"><a href="#async-std">6</a></sup>. And because the Async WG has made it an explicit goal to <a href="https://rust-lang.github.io/wg-async/vision/how_it_feels.html">bring
async Rust up to par with non-async Rust</a>, the issue of code
duplication is particularly relevant for the Async WG as well. Nobody on the
Async WG seems particularly keen on proposing we add a second instance of just
about every API currently in the stdlib.</p>
<div class="footnote-definition" id="async-std"><sup class="footnote-definition-label">6</sup>
<p>Some limitations in <code>async-std</code> apply: async Rust is missing async
<code>Drop</code>, async traits, and async closures. So not all APIs could be duplicated.
Also <code>async-std</code> explicitly didn't reimplement any of the collection APIs to be
async-aware, which means users are subject to the &quot;sandwich problem&quot;. The
purpose of <code>async-std</code> was to be a proving ground to test whether creating
an async mirror of the stdlib would be possible: and it's proven that it is, as
far as was possible with missing language features.</p>
</div>
<p>We're in a similar situation with <code>async</code> today as <code>const</code> was prior to 2018.
Duplicating entire interfaces and wrapping them in <code>block_on</code> calls is the
approach taken by e.g. the <code>mongodb</code>
[<a href="https://docs.rs/mongodb/latest/mongodb/index.html">async</a>,
<a href="https://docs.rs/mongodb/latest/mongodb/sync/index.html">non-async</a>], <code>postgres</code>
[<a href="https://docs.rs/tokio-postgres/latest/tokio_postgres/index.html">async</a>,
<a href="https://docs.rs/postgres/latest/postgres/">non-async</a>], and <code>reqwest</code>
[<a href="https://docs.rs/reqwest/latest/reqwest/">async</a>,
<a href="https://docs.rs/reqwest/latest/reqwest/blocking/index.html">non-async</a>] crates:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Async functionality like this would typically be exposed from a crate &quot;foo&quot;:
async fn bar() -&gt; Bar { 
    // async implementation goes here
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// And a sync counterpart would typically be exposed from a crate
// named &quot;blocking_foo&quot; or a submodule on the original crate as
// &quot;foo::blocking&quot;. This wraps the async code in a `block_on` call:
fn bar() -&gt; Bar {
    futures::executor::block_on(foo::bar())
}
<span class="boring">}
</span></code></pre></pre>
<p>This situation is not ideal. Instead of using the host's synchronous syscalls,
we're now going through an async runtime to get the same results - something
which is often not zero-cost. But more importantly, it's rather hard to
keep both a sync and async API version of the same crate in, err, sync with each
other. Without automation it's really easy for the two APIs to get out of sync,
leading to mismatched functionality.</p>
<p>The ecosystem has come up with some solutions to this, perhaps most notably the
proc-macro based <a href="https://docs.rs/maybe-async/0.2.6/maybe_async/"><code>maybe-async</code> crate</a>.  Instead of writing two
separate copies of <code>foo</code>, it generates a sync and async variant for you:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe_async]
async fn foo() -&gt; Bar { ... }
<span class="boring">}
</span></code></pre></pre>
<p>While being useful, the macro has clear limitations with respect to diagnostics
and ergonomics. That's absolutely not an issue with the crate, but an inherent
property of the problem it's trying to solve. Implementing a way to be generic
over the <code>async</code> keyword is something which will affect the language in many
ways, and a type system + compiler will be better equipped to handle it than
proc macros reasonably can.</p>
<h2 id="a-taste-of-trouble-the-sandwich-problem"><a class="header" href="#a-taste-of-trouble-the-sandwich-problem">A taste of trouble: the sandwich problem</a></h2>
<p>A pervasive issue in existing Rust is the <em>sandwich</em> problem. It occurs when a
type passed into an operation wants to perform control flow not supported by the
type it's passed into. Thus creating a <em>sandwich</em> <sup class="footnote-reference"><a href="#dilemma">7</a></sup> The classic example
is a <code>map</code> operation:</p>
<div class="footnote-definition" id="dilemma"><sup class="footnote-definition-label">7</sup>
<p>Not to be confused with the higher-order <em>sandwich dilemma</em> which is
when you look at the sandwich problem and attempt to determine whether the
sandwich is two slices of bread with a topping in between, or two toppings with
a slice of bread in between. Imo the operation part of the problem feels more
<em>bready</em>, but that would make for a weird-looking sandwich. Ergo: sandwich
dilemma. (yes, you can ignore all of this.)</p>
</div>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn map&lt;J&gt;(self, f: impl FnOnce(T) -&gt; J) -&gt; Option&lt;J&gt; { ... }
}

my_option.map(|x| x.await)
<span class="boring">}
</span></code></pre></pre>
<p>This will produce a compiler error: the closure <code>f</code> is not an async context, so
<code>.await</code> cannot be used within it. And we can't just convert the closure to be
<code>async</code> either, since <code>fn map</code> doesn't know how to call async functions. In
order to solve this issue, we could provide a new <code>async_map</code> method which
<em>does</em> provide an async closure. But we may want to repeat those for more
effects, and that would result in a combinatorial explosion of effects. Take for
example &quot;can fail&quot; and &quot;can be async&quot;:</p>
<table><thead><tr><th></th><th>not async</th><th>async</th></tr></thead><tbody>
<tr><td><strong>infallible</strong></td><td><code>fn map</code></td><td><code>fn async_map</code></td></tr>
<tr><td><strong>fallible</strong></td><td><code>fn try_map</code></td><td><code>fn async_try_map</code></td></tr>
</tbody></table>
<p>That's a lot of API surface for just a single method, and <strong>that problem
multiplies across the entire API surface in the stdlib</strong>. We expect that once we
start applying &quot;keyword generics&quot; to traits, we will be able to solve the
sandwich problem. The type <code>f</code> would be marked generic over a set of effects,
and the compiler would choose the right variant during compilation.</p>
<h2 id="affecting-all-effects"><a class="header" href="#affecting-all-effects">Affecting all effects</a></h2>
<p>Both <code>const</code> and <code>async</code> share a very similar issue, and we expect that other
&quot;effects&quot; will face the same issue. &quot;fallibility&quot; is particularly on our mind here,
but it isn't the only effect. In order for the language to feel consistent we
need consistent solutions.</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="q-is-there-an-rfc-available-to-read"><a class="header" href="#q-is-there-an-rfc-available-to-read">Q: Is there an RFC available to read?</a></h3>
<p>Rust initiatives are intended for <em>exploration</em>. The announcement of the Keyword
Generics Initiative marks the <em>start</em> of the exploration process. Part of
exploring is not knowing what the outcomes will be. Right now we're in the
&quot;pre-RFC&quot; phase of design. What we hope we'll achieve is to enumerate the
full problem space, design space, find a balanced solution, and eventually
summarize that in the form of an RFC. Then after the RFC is accepted: implement
it on nightly, work out the kinks, and eventually move to stabilize.  But we may
at any point during this process conclude that this initiative is actually
infeasible and start ramping down.</p>
<p>But while we can't make any <em>assurances</em> about the outcome of the initiative,
what we can share is that we're pretty optimistic about the initiative overall.
We wouldn't be investing the time we are on this if we didn't think we'd be
actually be able to see it through to completion.</p>
<h3 id="q-will-this-make-the-language-more-complicated"><a class="header" href="#q-will-this-make-the-language-more-complicated">Q: Will this make the language more complicated?</a></h3>
<p>The goal of keyword generics is not to minimize the complexity of the Rust
programming language, but to <em>minimize the complexity of programming in Rust.</em>
These two might sound similar, but they're not. Our reasoning here is that by
<em>adding</em> a feature, we will actually be able to significantly reduce the surface
area of the stdlib, crates.io libraries, and user code - leading to a more
streamlined user experience.</p>
<p>Choosing between sync or async code is a fundamental choice which needs to be
made. This is complexity which cannot be avoided, and which needs to exist
somewhere. Currently in Rust that complexity is thrust entirely on users of
Rust, making them responsible for choosing whether their code should support
async Rust or not. But other languages have made diferent choices. For example
Go doesn't distinguish between &quot;sync&quot; and &quot;async&quot; code, and has a runtime which
is able to remove that distinction.</p>
<p>In today's Rust application authors choose whether their application will be sync
or async, and even after the introduction of keyword generics we don't really
expect that to change. All generics eventually need to have their types known,
and keyword generics are no different. What we're targeting is the choice made
by <em>library</em> authors whether their library supports is sync or async. With
keyword generics library authors will be able to support both with the help of
the compiler, and leave it up to application authors to decide how they want to
compile their code.</p>
<h3 id="q-are-you-building-an-effect-system"><a class="header" href="#q-are-you-building-an-effect-system">Q: Are you building an effect system?</a></h3>
<p>The short answer is: kind of, but not really. &quot;Effect systems&quot; or &quot;algebraic
effect systems&quot; generally have a lot of surface area. A common example of what
effects allow you to do is implement your own <code>try/catch</code> mechanism. What we're
working on is intentionally limited to built-in keywords only, and wouldn't
allow you to implement anything like that at all.</p>
<p>What we do share with effect systems is that we're integrating modifier keywords
more directly into the type system. Modifier keywords like <code>async</code> are often
referred to as &quot;effects&quot;, so being able to be conditional over them in
composable ways effectively gives us an &quot;effect algebra&quot;. But that's very
different from &quot;generalized effect systems&quot; in other languages.</p>
<h3 id="q-are-you-looking-at-other-keywords-beyond-async-and-const"><a class="header" href="#q-are-you-looking-at-other-keywords-beyond-async-and-const">Q: Are you looking at other keywords beyond <code>async</code> and <code>const</code>?</a></h3>
<p>For a while we were referring to the initiative as &quot;modifier generics&quot; or
&quot;modifier keyword generics&quot;, but it never really stuck. We're only really
interested in keywords which modify how types work. Right now this is <code>const</code>
and <code>async</code> because that's what's most relevant for the const-generics WG and
async WG. But we're designing the feature with other keywords in mind as well.</p>
<p>The one most at the top of our mind is a future keyword for fallibility. There
is talk about introducing <code>try fn() {}</code> or <code>fn () -&gt; throws</code> syntax. This could
make it so methods such as <code>Iterator::filter</code> would be able to use <code>?</code> to break
out of the closure and short-circuit iteration.</p>
<p>Our main motivation for this feature is that without it, it's easy for Rust to
start to feel <em>disjointed</em>. We sometimes joke that Rust is actually 3-5
languages in a trenchcoat. Between const rust, fallible rust, async rust, unsafe
rust - it can be easy for common APIs to only be available in one variant of the
language, but not in others. We hope that with this feature we can start to
systematically close those gaps, leading to a more consistent Rust experience
for <em>all</em> Rust users.</p>
<h3 id="q-what-will-the-backwards-compatibility-story-be-like"><a class="header" href="#q-what-will-the-backwards-compatibility-story-be-like">Q: What will the backwards compatibility story be like?</a></h3>
<p>Rust has pretty strict backwards-compatibility guarantees, and any feature we
implement needs to adhere to this. Luckily we have some wiggle room because of
the edition mechanism, but our goal is to shoot for maximal backwards compat. We
have some ideas of how we're going to make this work though, and we're
cautiously optimistic we might actually be able to pull this off.</p>
<p>But to be frank: this is by far one of the hardest aspects of this feature, and
we're lucky that we're not designing any of this just by ourselves, but have the
support of the language team as well.</p>
<h3 id="q-arent-implementations-sometimes-fundamentally-different"><a class="header" href="#q-arent-implementations-sometimes-fundamentally-different">Q: Aren't implementations sometimes fundamentally different?</a></h3>
<p>Const Rust can't make any assumptions about the host it runs on, so it can't do
anything platform-specific. This includes using more efficient instructions of
system calls which are only available in one platform but not another. In order
to work around this, the <a href="https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html"><code>const_eval_select</code></a> intrinsic in the standard
library enables <code>const</code> code to detect whether it's executing during CTFE or
runtime, and execute different code based on that.</p>
<p>For async we expect to be able to add a similar intrinsic, allowing library
authors to detect whether code is being compiled as sync or async, and do
something different based on that. This includes: using internal concurrency, or
switching to a different set of system calls. We're not sure whether an
intrinsic is the right choice for this though; we may want to provide a more
ergonomic API for this instead. But because keyword generics is being designed
as a consistent feature, we expect that whatever we end up going with can be used
consistently by <em>all</em> modifier keywords.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this post we've introduced the new keyword generics initiative, explained why
it exists, and shown a brief example of what it might look like in the future.</p>
<p>The initiative is active on the Rust Zulip under
<a href="https://rust-lang.zulipchat.com/#narrow/stream/328082-t-lang.2Fkeyword-generics"><code>t-lang/keyword-generics</code></a> - if this seems interesting to you, please
pop by!</p>
<p><em>Thanks to everyone who's helped review this post, but in particular:
<a href="https://github.com/fee1-dead">fee1-dead</a>, <a href="https://github.com/danielhenrymantilla">Daniel Henry-Mantilla</a>, and <a href="https://github.com/rylev">Ryan Levick</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-report-february-2023"><a class="header" href="#progress-report-february-2023">Progress Report February 2023</a></h1>
<p><em>This post was originally posted on the <a href="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html">Inside Rust
Blog</a>,
but is included in this repository to be more easily referenced.</em></p>
<p>About 9 months ago <a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">we announced</a> the creation of the Keyword Generics
Initiative; a group working under the lang team with the intent to solve the 
<a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">function coloring problem</a> <sup class="footnote-reference"><a href="#color">1</a></sup> through the type system not just for
<code>async</code>, but for <code>const</code> and all current and future function modifier keywords
as well.</p>
<p>We're happy to share that we've made a lot of progress over these last several
months, and we're finally ready to start putting some of our designs forward through
RFCs. Because it's been a while since our last update, and because we're excited
to share what we've been working on, in this post we'll be going over some of the things
we're planning to propose.</p>
<div class="footnote-definition" id="color"><sup class="footnote-definition-label">1</sup>
<p>To briefly recap this problem: you can't call an <code>async fn</code> from a
non-async fn. This makes the &quot;async&quot; notation go viral, as every function that
calls it also needs to be async. But we believe possibly more importantly: it
requires a duplication of most stdlib types and ecosystem libraries. Instead we
suspected we might be able to overcome this issue by introducing a new kind of
generic which would enable functions and types to be &quot;generic&quot; over whether
they're async or not, const or not, etc.</p>
</div>
<h2 id="an-async-example"><a class="header" href="#an-async-example">An async example</a></h2>
<p>In our <a href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">previous post</a> we introduced the placeholder <code>async&lt;A&gt;</code> syntax to describe the
concept of a &quot;function which is generic over its asyncness&quot;. We always knew we
wanted something that felt lighter weight than that, so in for our current design
we've chosen to drop the notion of a generic parameter for the end-user syntax,
and instead picked the <code>?async</code> notation. We've borrowed this from the trait
system, where for example <code>+ ?Sized</code> indicates that something may or may not
implement the <code>Sized</code> trait. Similarly <code>?async</code> means a function may or may not be
async. We also refer to these as &quot;maybe-async&quot; functions.</p>
<p>Time for an example. Say we took the <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code> trait</a> and the
<a href="https://doc.rust-lang.org/std/io/fn.read_to_string.html">read_to_string_methods</a>. In the stdlib their implementations look somewhat
like this today:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { ... }
}

/// Read from a reader into a string.
fn read_to_string(reader: &amp;mut impl Read) -&gt; std::io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string)?;
    Ok(string)
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, what if we wanted to make these async in the future? Using <code>?async</code>
notation we could change them to look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ?async Read {
    ?async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    ?async fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { ... }
}

/// Read from a reader into a string.
?async fn read_to_string(reader: &amp;mut impl ?async Read) -&gt; std::io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string).await?;
    Ok(string)
}
<span class="boring">}
</span></code></pre></pre>
<p>The way this would work is that <code>Read</code> and <code>read_to_string</code> would become generic over
their &quot;asyncness&quot;. When compiled for an <code>async</code> context, they will behave
asynchronously. When compiled in a non-async context, they will behave
synchronously. The <code>.await</code> in the <code>read_to_string</code> function body is necessary
to mark the cancellation point in case the function is compiled as async; but
when not async would essentially become a no-op <sup class="footnote-reference"><a href="#always-async-maybe">2</a></sup>:</p>
<div class="footnote-definition" id="always-async-maybe"><sup class="footnote-definition-label">2</sup>
<p>One restriction <code>?async</code> contexts have is that they can
only call other <code>?async</code> and non-<code>async</code> functions. Because if we could call an
always-<code>async</code> function, there would be no clear right thing to do when compiled
in non-async mode. So things like async concurrency operations won't directly
work in always-async contexts. But we have a way out of this we talk about later
in the post: <code>if is_async() .. else ..</code>. This allows you to branch the body of a
<code>?async fn</code> based on which mode it's being compiled in, and will allow you to
write different logic for async and non-async modes. This means you can choose
to use async concurrency in the async version, but keep things sequential in the
non-async version.</p>
</div>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `read_to_string` is inferred to be `!async` because
// we didn't `.await` it, nor expected a future of any kind.
#[test]
fn sync_call() {
    let _string = read_to_string(&quot;file.txt&quot;)?;
}

// `read_to_string` is inferred to be `async` because
// we `.await`ed it.
#[async_std::test]
async fn async_call() {
    let _string = read_to_string(&quot;file.txt&quot;).await?;
}
<span class="boring">}
</span></code></pre></pre>
<p>We expect <code>?async</code> notation would be most useful for library code which doesn't
do anything particularly specific to async Rust. Think: most of the stdlib, and
ecosystem libraries such as parsers, encoders, and drivers. We expect most
applications to choose to be compiled either as async or non-async, making them
mostly a consumer of <code>?async</code> APIs.</p>
<h2 id="a-const-example"><a class="header" href="#a-const-example">A const example</a></h2>
<p>A main driver of the keywords generics initiative has been our desire to make the
different modifier keywords in Rust feel consistent with one another. Both the
const WG and the async WG were thinking about introducing keyword-traits at the
same time, and we figured we should probably start talking with each other to make
sure that what we were going to introduce felt like it was part of the same
language - and could be extended to support more keywords in the future.</p>
<p>So with that in mind, it may be unsurprising that for the maybe-<code>const</code> trait
bounds and declarations we're going to propose using the <code>?const</code> notation.
A common source of confusion with <code>const fn</code> is that it actually doesn't
guarantee compile-time execution; it only means that it's <em>possible</em> to evaluate
in a <code>const</code> compile-time context. So in a way <code>const fn</code> has always been a way
of declaring a &quot;maybe-const&quot; function, and there isn't a way to declare an
&quot;always-const&quot; function. More on that later in this post.</p>
<p>Taking the <code>Read</code> example we used earlier, we could imagine a &quot;maybe-const&quot; version
of the <code>Read</code> trait to look very similar:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ?const Read {
    ?const fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    ?const fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Which we could then use use as a bound in the const <code>read_to_string</code> function,
like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn read_to_string(reader: &amp;mut impl ?const Read) -&gt; std::io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string)?;
    Ok(string)
}
<span class="boring">}
</span></code></pre></pre>
<p>Just like with <code>?async</code> traits, <code>?const</code> traits would also need to be labeled as
<code>?const</code> when used as a bound. This is important to surface at the trait level,
because it's allowed to pass non-const bounds to maybe-const functions, as long
as no trait methods are called in the function body. This means we need to
distinguish between &quot;never-const&quot; and &quot;maybe-const&quot;.</p>
<p>You may have noticed the <code>?const</code> on the trait declaration and the extra
<code>?const</code> on the trait methods. This is on purpose: it keeps the path open to
potentially add support for &quot;always-const&quot; or &quot;never-const&quot; methods on traits as
well. In <code>?async</code> we know that even if the entire trait is <code>?async</code>, some
methods (such as <code>Iterator::size_hint</code>) will never be async. And this would
make <code>?const</code> and <code>?async</code> traits behave similarly using the same rules.</p>
<h2 id="combining-const-and-async"><a class="header" href="#combining-const-and-async">Combining const and async</a></h2>
<p>We've covered <code>?async</code>, and we've covered <code>?const</code>. Now what happens if we were
to use them together? Let's take a look at what the <code>Read</code> trait would look like
when if we extended it using our designs for <code>?const</code> and <code>?async</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ?const ?async Read {
    ?const ?async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    ?const ?async fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { .. }
}

/// Read from a reader into a string.
const ?async fn read_to_string(reader: &amp;mut impl ?const ?async Read) -&gt; io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string).await?;
    Ok(string)
}
<span class="boring">}
</span></code></pre></pre>
<p>That's sure starting to feel like a lot of keywords, right? We've accurately
described exactly what's going on, but there's a lot of repetition. We know that
if we're dealing with a <code>const ?async fn</code>, most arguments probably will
want to be <code>?const ?async</code>. But under the syntax rules we've proposed so far,
you'd end up repeating that everywhere. And it probably gets worse once we start
adding in more keywords. Not ideal!</p>
<p>So we're very eager to make sure that we find a solution to this. And we've been
thinking about a way we could get out of this, which we've been calling
<code>effect/.do</code>-notation. This would allow you to mark a function as &quot;generic over
all modifier keywords&quot; by annotating it as <code>effect fn</code>, and it would allow the
compiler to insert all the right <code>.await</code>, <code>?</code>, and <code>yield</code> keywords in the
function body by suffixing function calls with <code>.do</code>.</p>
<p>Just to set some expectations: this is the least developed part of our proposal,
and we don't intend to formally propose this until after we're done with some of
the other proposals. But we think it's an important part of the entire vision,
so we wanted to make sure we shared it here. And with that out of the way,
here's the same example we had above, but this time using the <code>effect/.do</code>-notation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ?effect Read {
    ?effect fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    ?effect fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; { .. }
}

/// Read from a reader into a string.
?effect fn read_to_string(reader: &amp;mut impl ?effect Read) -&gt; std::io::Result&lt;String&gt; {
    let mut string = String::new();
    reader.read_to_string(&amp;mut string).do;  // note the singular `.do` here
    string
}
<span class="boring">}
</span></code></pre></pre>
<p>One of the things we would like to figure out as part of <code>effect/.do</code> is a way
to enable writing conditional effect-bounds. For example: there may be a
function which is always async, may never panic, and is generic over the
remainder of the effects. Or like we're seeing with APIs such as
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve"><code>Vec::reserve</code></a> and <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve"><code>Vec::try_reserve</code></a>: the ability to panic xor return an
error. This will take more time and research to figure out, but we believe it
is something which can be solved.</p>
<h2 id="adding-support-for-types"><a class="header" href="#adding-support-for-types">Adding support for types</a></h2>
<p>Something we're keen on doing is not just adding support for <code>?async</code> and to
apply to functions, traits, and trait bounds. We would like <code>?async</code> to be
possible to use with types as well. This would enable the ecosystem to stop
having to provide both sync and async versions of crates. It would also enable
the stdlib to gradually &quot;asyncify&quot; just like we have been with const.</p>
<p>The challenge with async types, especially in the stdlib, is that their behavior
will often have to be different when used in async and non-async contexts. At
the very lowest level async system calls work a bit differently from non-async
system calls. But we think we may have a solution for that too in the form of
the <code>is_async</code> compiler built-in method.</p>
<p>Say we wanted to implement <code>?async File</code> with a single <code>?async open</code> method. The
way we expect this to look will be something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A file which may or may not be async
struct ?async File {
    file_descriptor: std::os::RawFd,  // shared field in all contexts
    async waker: Waker,               // field only available in async contexts
    !async meta: Metadata,            // field only available in non-async contexts
}

impl ?async File {
    /// Attempts to open a file in read-only mode.
    ?async fn open(path: Path) -&gt; io::Result&lt;Self&gt; {
        if is_async() {   // compiler built-in function
            // create an async `File` here; can use `.await`
        } else {
            // create a non-async `File` here
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This would enable authors to use different fields depending on whether they're
compiling for async or not, while still sharing a common core. And within
function bodies it would be possible to provide different behaviors depending on
the context as well. The function body notation would work as a generalization
of the currently unstable <a href="https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html"><code>const_eval_select</code></a> intrinsic, and at
least for the function bodies we expect a similar <code>is_const()</code> compiler built-in
to be made available as well.</p>
<h2 id="consistent-syntax"><a class="header" href="#consistent-syntax">Consistent syntax</a></h2>
<p>As we alluded to earlier in the post: one of the biggest challenges we see in
language design is adding features in a way that makes them feel like they're in
harmony with the rest of the language - and not something which stands out as
noticably different. And because we're touching on something core to Rust, the
way we do keywords, we have to pay extra close attention here to make sure Rust
keeps feeling like a single language.</p>
<p>Luckily Rust has the ability to make surface-level changes to the
language through the edition system. There are many things this doesn't let us
do, but it does allow us to require syntax changes. A possibility we're
exploring is leveraging the edition system to make some minor changes to <code>const</code>
and <code>async</code> so they feel more consistent with one another, and with <code>?const</code> and
<code>?async</code>.</p>
<p>For <code>const</code> this means there should be a syntactic distinction between <code>const</code>
declarations and <code>const</code> uses. Like we mentioned earlier in the post, when you
write <code>const fn</code> you get a function which can be evaluated both at runtime and
during compilation. But when you write <code>const FOO: () = ..;</code> the meaning of
<code>const</code> there guarantees compile-time evaluation. One keyword, different
meanings. So for that reason we're wondering whether perhaps it would make more
sense if we changed <code>const fn</code> to <code>?const fn</code>.  This would make it clear that
it's a function which <em>may</em> be const-evaluated, but doesn't necessarily have to -
and can also be called from non-<code>const</code> contexts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Define a function which may be evaluated both at runtime and during
//! compilation.

// Current
const fn meow() -&gt; String { .. }

// Proposed
?const fn meow() -&gt; String { .. }
<span class="boring">}
</span></code></pre></pre>
<p>For <code>async</code> we're considering some similar surface-level changes.  The Async WG
is in the process of expanding the &quot;async functions in traits&quot; design into an
design covering &quot;async traits&quot; entirely, largely motivated by the desire to be
able to add <code>+ Send</code> bound to anonymous futures. There are more details about
this in <a href="https://blog.theincredibleholk.org/blog/2023/02/16/lightweight-predictable-async-send-bounds/">&quot;Lightweight, Predictable Async Send Bounds&quot;</a> by Eric
Holk. But it would roughly become the following notation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct File { .. }
impl async Read for File {                                                // async trait declaration
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; { .. }  // async method
}

async fn read_to_string(reader: &amp;mut impl async Read) -&gt; io::Result&lt;String&gt; { // async trait bound
    let mut string = String::new();
    reader.read_to_string(&amp;mut string).await?;
    Ok(string)
}
<span class="boring">}
</span></code></pre></pre>
<p>This would make <code>impl ?async Read</code> and <code>impl async Read</code> consistent with each
other. And it would open the door for <code>trait ?async</code> traits to be passed to
<code>impl async Read</code> and be guaranteed to be always interpreted as <code>trait async</code>.
Which is another nice consistency gain.</p>
<p>The final thing we're looking at is <code>async</code>-notation for types. To implement
inherent <code>?async</code> methods on types, our current design requires the type to also
be marked as <code>?async</code>. In order to bring <code>?async</code> and <code>async</code> closer together,
we're exploring whether it might also make sense to require types to be marked
as <code>async</code> as well:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Proposed: define a method on a maybe-async type
struct ?async File { .. }
impl ?async File {
    ?async fn open(path: PathBuf) -&gt; io::Result&lt;Self&gt; { .. }
}

//! Current: define a method on an always-async type
struct File { .. }
impl File {
    async fn open(path: PathBuf) -&gt; io::Result&lt;Self&gt; { .. }
}

//! Proposed: define a method on an always-async type
struct async File { .. }
impl async File {
    async fn open(path: PathBuf) -&gt; io::Result&lt;Self&gt; { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>We already have something similar going on for &quot;always-const&quot; arguments via the
const-generics system. These look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;const N: usize&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<p>Every &quot;always-const&quot; argument to the function must always be marked by <code>const</code>,
so it wouldn't be entirely without precedent for every &quot;always-async&quot; type to
always require to be marked using <code>async</code>. So we're exploring some of what might
be possible here.</p>
<h2 id="the-tentative-plan"><a class="header" href="#the-tentative-plan">The tentative plan</a></h2>
<p>We plan to initially focus our efforts on the <code>async</code> and <code>const</code> keywords only.
We're feeling ready to start converting some of our designs into RFCs, and start
putting them out for review. In the coming months we expect to start writing
the following proposals (in no particular order):</p>
<ul>
<li><code>?async fn</code> notation without trait bounds, including an <code>is_async</code> mechanism.</li>
<li><code>trait async</code>  declarations and bounds.</li>
<li><code>trait ?async</code> declarations and bounds, <code>trait ?const</code> declarations and bounds.</li>
<li><code>?const fn</code> notation without trait bounds.</li>
<li><code>struct async</code> notation and <code>struct ?const</code> notation.</li>
</ul>
<p>We'll be working closely with the Lang Team, Const WG, and Async WG on these
proposals, and in some cases (such as <code>trait async</code>) we may even take an
advising role with a WG directly driving the RFC. As usual, these will be going
through the RFC-nightly-stabilization cycle. And only once we're fully confident
in them will they become available on stable Rust.</p>
<p>We're intentionally not yet including <code>effect/.do</code> notation on this roadmap. We
expect to only be able to start this work once we have <code>?async</code> on nightly,
which we don't yet have. So for now we'll continue work on designing it within
the initiative, and hold off on making plans to introduce it quiet yet.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>And that concludes the 9-month progress report of the Keyword Generics
Initiative. We hope to be able to provide more exact details about things such
as desugarings, semantics, and alternatives in the RFCs. We're pretty stoked with the
progress we've made in these past few months! Something which I don't think
we've mentioned yet, but is probably good to share: we've actually prototyped
much of the work in this post already; so we're feeling fairly confident all of
this may actually <em>actually</em> work. And that is something we're
incredibly excited for!</p>
<div style="break-before: page; page-break-before: always;"></div><iframe class="youtube-video"
src="https://www.youtube-nocookie.com/embed/MTnIexTt9Dk"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>
<p><em>This was originally posted on <a href="https://blog.yoshuawuyts.com/extending-rusts-effect-system/">Yosh's
blog</a>, but included
in this repository to be more easily referenced.</em></p>
<p><em>This is the transcript of the RustConf 2023 talk: &quot;Extending Rust's Effect
System&quot;, presented on September 13th 2023 in Albuquerque, New Mexico and
streamed online.</em></p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Rust has continuously evolved since version 1.0 was released in 2015. We've
added major features such as the try operator (<code>?</code>), const generics, generic
associated types (GATs), and of course: <code>async/.await</code>. Out of those four
features, three are what can be considered to be &quot;effects&quot;. And though we've
been working on them for a long time, they are all still very much in-progress.</p>
<p>Hello, my name is Yosh and I work as a Developer Advocate for Rust at Microsoft.
I've been working on Rust itself for the past five years, and I'm among other
things a member of the Rust Async WG, and the co-lead of the Rust Effects
Initiative.</p>
<p>The thesis of this talk is that we've unknowingly shipped an effect system as
part of the language in since Rust 1.0. We've since begun adding a number of new
effects, and in order to finish integrating them into the language we need
support for <em>effect generics</em>.</p>
<p>In this talk I'll explain what effects are, what makes them challenging to
integrate into the language, and how we can overcome those challenges.</p>
<h2 id="rust-without-generics"><a class="header" href="#rust-without-generics">Rust Without Generics</a></h2>
<p>When I was new to Rust it took me a minute to figure out how to use generics. I
was used to writing JavaScript, and we don‚Äôt have generics there. So I found
myself mostly writing functions which operated on <em>concrete types</em>. I remember
my code felt pretty clumsy, and it wasn't a great experience. Not compared to,
say, the code the stdlib provides.</p>
<p>An example of a generic stdlib function is the <code>io::copy</code> function. It reads
bytes from a reader, and copies them into a writer. We can give it a file, a
socket, or any combination of the two, and it will happily copy bytes from one
into the other.  This all works as long as we give it the right types.</p>
<p>But what if Rust actually didn't have generics? What if the Rust I used to write
at the beginning was actually all we had? How would we write this <code>io::copy</code>
function? Well, given we're trying to copy bytes between sockets and file types,
we could probably hand-code individual functions for these. For our two types
here we could write four unique functions.</p>
<p>But unfortunately for us that would only solve the problem right in front of us.
But the stdlib doesn‚Äôt just have two types which implement read and write. It
has 18 types which implement read, and 27 types which implement write. So if we
wanted to cover the entire API space of the stdlib, we‚Äôd need 486 functions in
total. And if that was the only way we could implement <code>io::copy</code>, that would
make for a pretty bad language.</p>
<p>Now luckily Rust does have generics, and all we ever need is the one <code>copy</code>
function. This means we're free to keep adding more types into the stdlib
without having to worry about implementing more functions. We just have the one
<code>copy</code> function, and the compiler will take care of generating the right code
for any types we give it.</p>
<h2 id="why-effect-generics"><a class="header" href="#why-effect-generics">Why effect generics?</a></h2>
<p>Types are not the only things in Rust we want to be generic over. We also have
&quot;const generics&quot; which allow functions to be generic over constant values. As
well as &quot;value generics&quot; which allow functions to be generic over different
values. This is how we can write functions which can take different values -
which is a feature present in most programming languages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn by_value(cat: Cat) { .. }
fn by_reference(cat: &amp;Cat) { .. }
fn by_mutable_reference(cat: &amp;mut Cat) { .. }
<span class="boring">}
</span></code></pre></pre>
<p>But not everything that can lead to API duplication are things we can be generic
over. For example, it's pretty common to create different methods or types
depending on whether we take a value as owned, as a reference, or as a mutable
reference. We also often create duplicate APIs for constant values and for
runtime values. As well as create duplicate structures depending on whether the
API needs to be thread-safe or not.</p>
<p>But out of everything which can lead to API duplication, effects are probably
one of the biggest ones. When I talk about effects in Rust, what I mean is
certain keywords such as <code>async/.await</code> and <code>const</code>; but also <code>?</code>, and types
such as <code>Result</code>, and <code>Option</code>. All of these have a deep, semantic connection to
the language, and changes the meaning of our code in ways that other keywords
and types don't.</p>
<p>Sometimes we'll write code which doesn't have the right effects, leading to
<em>effect mismatches</em>. This is also known as the <em>function coloring problem</em>, as
described by Robert Nystrom. Once you become aware of <em>effect mismatches</em> you
start seeing them all over the place, not just in Rust either.</p>
<p>The result of these effect mismatches is that using effects in Rust essentially
drops you into a second-rate experience. Whether you're using const, async,
Result, or Error - almost certainly somewhere along the line you'll run into a
compatibility issue.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let db: Option&lt;Database&gt; = ..;
let db = db.filter(|db| db.name? == &quot;chashu&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Take for example the <code>Option::filter</code> API. It takes a type by reference and
returns a bool. If we try and use the <code>?</code> operator inside of it we get an error,
because the function doesn't return <code>Result</code> or <code>Option</code>. Not being able to use
<code>?</code> inside of arbitrary closures is an example of an effect mismatch.</p>
<p>But simple functions like that only scratch the surface. Effect mismatches are
present in almost every single trait in the stdlib too. Take for example
something common like the <code>Debug</code> trait which is implemented on almost every
type in Rust.</p>
<p>We could implement the <code>Debug</code> trait for our made-up type <code>Cat</code>. The parameter
<code>f</code> here implements <code>io::Write</code> and represents a stream of bytes. And using the
<code>write!</code> macro we can write bytes into that stream. But if for some reason we
wanted to write bytes asynchronously into, say, an async socket. Well, we can't
do that. <code>fn fmt</code> is not an async function, which means we can't await inside of
it.</p>
<p>One way out of this could be to create some kind of intermediate buffer, and
synchronously write data into it. We could then write data out of that buffer
asynchronously. But that would involve extra copies we didn't have before.</p>
<p>If we wanted to make it identical to what we did before, the solution would be
to create a <em>new</em> <code>AsyncDebug</code> trait which <em>can</em> write data asynchronously into
the stream. But we now have duplicate traits, and that's exactly the problem
we're trying to prevent.</p>
<p>It's tempting to say that maybe we should just add the <code>AsyncDebug</code> trait and
call it a day. We can then also add async versions of <code>Read</code>, <code>Write</code>, and
<code>Iterator</code> too. And perhaps <code>Hash</code> as well, since it too writes to an output
stream. And what about <code>From</code> and <code>Into</code>? Perhaps <code>Fn</code>, <code>FnOnce</code>, <code>FnMut</code>, and
<code>Drop</code> too since they're built-ins? And so on. The reality is that effect
mismatches are structural, and duplicating the API surface for every effect
mismatch leads to an exponential explosion of APIs. Which is similar to what
we've seen with data type generics earlier on.</p>
<p>Let me try and illustrate this for a second. Say we took the existing family of
<code>Fn</code> traits and introduced effectful versions of them. That is: versions which
work with <code>unsafe</code> <sup class="footnote-reference"><a href="#unsafe-note">1</a></sup>, <code>async</code>, <code>try</code>, <code>const</code>, and generators. With one effect
we're up to six unique traits. With two effects we're up to twelve. With all
five we're suddenly looking at 96 different traits.</p>
<div class="footnote-definition" id="unsafe-note"><sup class="footnote-definition-label">1</sup>
<p>Correction from 2024: after having discussed this with Ralf Jung
we've concluded that semantically <code>unsafe</code> in Rust is not an effect. But
syntactically it would be fair to say that <code>unsafe</code> is &quot;effect-like&quot;. As such
any notion of &quot;maybe-unsafe&quot; would be nonsensical. We don't discuss such a
feature in this talk, but it is worth clearing up ahead of time in case this
leaves people wondering.</p>
</div>
<p>The problem space in the stdlib is really broad. From analyzing the Rust 1.70
stdlib, by my estimate about 75% of the stdlib would interact with the const
effect. Around 65% would interact with the async effect. And around 30% would
interact with the try effect. The exact numbers are imprecise because parts of
the various effects are still in-progress. How much this will result in
practice, very much will depend on how we end up designing the language.</p>
<p>If you compare the numbers then it appears that close to 100% of the stdlib
would interact with one or more effect. And about 50% would interact with two or
more effects. If we consider that whenever effects interact with each other they
can lead to exponential blowup, this should warn us that clever one-off
solutions won't cut it. I believe that the best way to deal with this is to
instead allow Rust to enable items to be generic over effects.</p>
<h2 id="stage-i-effect-generic-trait-definitions"><a class="header" href="#stage-i-effect-generic-trait-definitions">Stage I: Effect-Generic Trait Definitions</a></h2>
<p>Now that we've taken a good look at what happens when we can't be generic over
effects, it's time we start talking about what we can do about it. The answer,
unsurprisingly, is to introduce effect generics into the language. To cover all
uses will take a few steps, so let's start with the first, and arguably most
important one: effect-generic trait definitions.</p>
<p>This is important because it would allow us to introduce effectful traits as
part of the stdlib. Which would among other things would help standardize the
various async ecosystems around the stdlib.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Into&lt;T&gt;: Sized {     
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Into&lt;Loaf&gt; for Cat {     
    fn into(self) -&gt; Loaf {
        self.nap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's use a simple example here: the <code>Into</code> trait. The <code>Into</code> trait is used to
convert from one type into another. It is generic over a type <code>T</code>, and has one
function &quot;into&quot; which consumes <code>Self</code> and returns the type <code>T</code>. Say we have a
type cat which when it takes a nap turns into a cute little loaf. We can
implement <code>Into&lt;Loaf&gt;</code> for <code>Cat</code> by calling <code>self.nap</code> in the function body.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsyncInto&lt;T&gt;: Sized {     
    async fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AsyncInto&lt;Loaf&gt; for Cat {     
    async fn into(self) -&gt; Loaf {
        self.nap().await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>But what if the cat doesn't take a nap straight away? Maybe <code>nap</code> should
actually be an async function. In order to <code>await</code> nap inside the trait impl,
the <code>into</code> method would need to be async. If we were writing an async trait from
scratch, we could do this by exposing a new <code>AsyncInto</code> trait with an async
<code>into</code> method.</p>
<p>But we don't just want to add a new trait to the stdlib, instead we want to
<em>extend</em> the existing <code>Into</code> trait to work with the async effect. The way we
could extend the <code>Into</code> trait with the <code>async</code> effect is by making the async
effect <em>optional</em>. Rather than requiring that the trait is always sync or async,
implementors should be able to choose which version of the trait they want to
implement.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
impl Into&lt;Loaf&gt; for Cat {     
    #[maybe(async)]
    fn into(self) -&gt; Loaf {
        self.nap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The way this would work is by adding a new notation on the trait: &quot;maybe async&quot;.
We don't yet know what syntax we want to use for &quot;maybe async&quot;, so in this talk
we'll be using attributes. The way the &quot;maybe async&quot; notation works is that we
mark all methods which we want to be &quot;maybe async&quot; as such. And then mark our
trait itself as &quot;maybe async&quot; too.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Into&lt;Loaf&gt; for Cat {     
    fn into(self) -&gt; Loaf {
        self.nap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl async Into&lt;Loaf&gt; for Cat {     
    async fn into(self) -&gt; Loaf {
        self.nap().await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementors then get to choose whether they want to implement the sync or async
versions of the trait. And depending on which version they choose, the methods
then ends up being either sync or async. This system would be entirely
backwards-compatible, because implementing the sync version of <code>Into</code> would
remain the same as it is today. But people who want to implement the async
version would be able to, just by adding a few extra <code>async</code> keywords to the impl.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl async Into&lt;Loaf&gt; for Cat {
    async fn into(self) -&gt; Loaf {
        self.nap().await
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Into&lt;Loaf, true&gt; for Cat {
    type ReturnTy = impl Future&lt;Output = Loaf&gt;;
    fn into(self) -&gt; Self::ReturnTy {
        async move {
            self.nap().await
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Under the hood the implementations desugars to regular Rust code we can already
write today. The sync implementation of the type returns a type <code>T</code>. But the
async impl returns an <code>impl Future</code> of <code>T</code>. Under the hood it is just a single
const bool and some associated types.</p>
<ul>
<li>good diagnostics</li>
<li>gradual stabilization,</li>
<li>backwards-compatibility</li>
<li>clear inference rules</li>
</ul>
<p>It would be reasonable to ask why we're bothering with a language feature, if
the desugaring ends up being so simple. And the reason is: effects are
everywhere, and we want to make sure effect generics feel like part of the
language. That not only means that we want to tightly control the diagnostics.
We also want to enable them to be gradually introduced, have clear language
rules, and be backwards-compatible.</p>
<p>But if you keep all that in mind, it's probably okay to think of effect generics
as mostly syntactic sugar for const bools + associated types.</p>
<h2 id="stage-ii-effect-generic-bounds-impls-and-types"><a class="header" href="#stage-ii-effect-generic-bounds-impls-and-types">Stage II: Effect-Generic Bounds, Impls, and Types</a></h2>
<p>Being able to declare effect-generic traits is only the beginning. The stdlib
not only exposes traits, it also exposes various types and functions. And
effect-generic traits don't directly help with that.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn copy&lt;R, W&gt;(
    reader: &amp;mut R,
    writer: &amp;mut W
) -&gt; io::Result&lt;()&gt;
where
    R: Read,
    W: Write;
<span class="boring">}
</span></code></pre></pre>
<p>Let's take our earlier <code>io::copy</code> example again. As we've said <code>copy</code> takes a
reader and writer, and then copies bytes from the reader to the writer. We've
seen this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn async_copy&lt;R, W&gt;(
    reader: &amp;mut R,
    writer: &amp;mut W
) -&gt; io::Result&lt;()&gt;
where
    R: AsyncRead,
    W: AsyncWrite;
<span class="boring">}
</span></code></pre></pre>
<p>Now what would it look like if we tried adding an async version of this to the
stdlib today. Well, we'd need to start by giving it a different name so it
doesn't conflict with the existing <code>copy</code> function. The same goes for the trait
bounds as well, so instead of taking <code>Read</code> and <code>Write</code>, this function would
take <code>AsyncRead</code> and `AsyncWrite.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn async_copy&lt;R, W&gt;(
    reader: &amp;mut R,
    writer: &amp;mut W
) -&gt; io::Result&lt;()&gt;
where
    R: async Read,
    W: async Write;
<span class="boring">}
</span></code></pre></pre>
<p>Now things get a little better once we have effect-generic trait definitions.
Rather than needing to take async duplicates of the <code>Read</code> and <code>Write</code> traits,
the function can instead choose the async versions of the existing <code>Read</code> and
<code>Write</code> traits. That's already better, but it still means we have two versions
of the <code>copy</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub fn copy&lt;R, W&gt;(
    reader: &amp;mut R,
    writer: &amp;mut W
) -&gt; io::Result&lt;()&gt;
where
    R: #[maybe(async)] Read,
    W: #[maybe(async)] Write;
<span class="boring">}
</span></code></pre></pre>
<p>Instead the ideal solution would be to allow <code>copy</code> itself to be generic over
the async effect, and make that determine which versions of <code>Read</code> and <code>Write</code>
we want. These are what we call &quot;effect-generic bounds&quot;. The effect of the
function and the effect of the bounds it takes all become the same. In
literature this is also known as &quot;row-polymorphism&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>copy(reader, writer)?;                // infer sync
copy(reader, writer).await?;          // infer async
copy::&lt;async&gt;(reader, writer).await?; // force async
<span class="boring">}
</span></code></pre></pre>
<p>Because the function itself is now generic over the async effect, we need to
figure out at the call-site which variant we intended to use. This system will
make use of <em>inference</em> to figure it out. That's a fancy way of saying that
the compiler is going to make an educated guess about which effects the
programmer intended to use. If they used <code>.await</code> they probably wanted the async
version. Otherwise they probably wanted the sync version. But as with any guess:
sometimes we guess wrong, so for that reason we want to provide an escape hatch
by enabling program authors to force the variant. We don't know the exact syntax
for this yet, but we assume this would likely be using the turbofish notation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct File { .. }
impl File {
    fn open&lt;P&gt;(p: P) -&gt; Result&lt;Self&gt;
    where
        P: AsRef&lt;Path&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>But effect-generics aren't just needed for functions. If we want to make the
stdlib work well with effects, then types will need effect-generics too. This
might seem strange at first, since an &quot;async type&quot; might not be very intuitive.
But for example files on Windows need to be initialized as either sync or async.
Which means that whether they're async or not isn't just a property of the
functions, it's a property of the type.</p>
<p>Let's use the stdlib's <code>File</code> type as our example here. For simplicity let's
assume it has a single method: <code>open</code> which returns either an error or a file.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AsyncFile { .. }
impl AsyncFile {
    async fn open&lt;P&gt;(p: P) -&gt; Result&lt;Self&gt;
    where
        P: AsRef&lt;AsyncPath&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>If we wanted to provide an async version of <code>File</code>, we again would need to
duplicate our interfaces. That means a new type <code>AsyncFile</code>, which has a new
async method <code>open</code>, which takes an async version of <code>Path</code> as an argument. And
<code>Path</code> needs to be async because it itself has async filesystem methods on it.
As I've said before: once you start looking you notice effects popping up
everywhere.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
struct File { .. }

#[maybe(async)] 
impl File {
    #[maybe(async)]
    fn open&lt;P&gt;(p: P) -&gt; Result&lt;Self&gt;
    where
        P: AsRef&lt;#[maybe(async)] Path&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Instead of creating a second <code>AsyncFile</code> type, with effect generics on types
we'd be able to open <code>File</code> as async instead. Allowing us to keep just the one
<code>File</code> definition for both sync and async variants.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
fn copy&lt;R, W&gt;(reader: R, writer: W) -&gt; io::Result&lt;()&gt; {
    let mut buf = vec![4028];
    loop {
        match reader.read(&amp;mut buf).await? {
            0 =&gt; return Ok(()),
            n =&gt; writer.write_all(&amp;buf[0..n]).await?,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now I've sort of hand-waved away the internal implementations of both the <code>copy</code>
function and the <code>File</code> type. The way they work is a little different for the
two. In the case of the <code>copy</code> function, the implementation between the async
and non-async variants would be identical. If the function is compiled as async,
everything works as written. But if the function compiles as sync, then we just
remove the <code>.await</code>s and the function should compile as expected.</p>
<p>As a result of this &quot;maybe-async&quot; functions can only call sync or other
&quot;maybe-async&quot; functions. But that should be fine for most cases.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl File {
    #[maybe(async)]
    fn open&lt;P&gt;(p: P) -&gt; Result&lt;Self&gt; {
        if IS_ASYNC { .. } else { .. }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Concrete types like <code>File</code> are a little trickier. They often want to run
different code depending on which effects it has. Luckily types like <code>File</code>
already conditionally compile different code depending on the platform, so
introducing new types conditions shouldn't be too big of a jump. The key thing
we need is a way to detect in the function body whether code is being compiled
as async or not - basically a fancy bool.</p>
<p>We can already do this for the const effect using the <code>const_eval_select</code>
intrinsic. It's currently unstable and a little verbose, but it works reliably.
We should be able to easily adapt it to something similar for async and the rest
of the effects too.</p>
<h2 id="what-are-effects"><a class="header" href="#what-are-effects">What are effects?</a></h2>
<p>Systems research on effects has been a topic in computer science for nearly 40
years. That's about as old as C++. It's become a bit of a hot topic recently in
PL spheres with research languages such as Koka, Eff, and Frank showing how
effects can be useful. And languages such as Scala, and to a lesser extent
Swift, adopting effect features.</p>
<p>When people talk about effects they will broadly refer to one of two things:</p>
<ul>
<li><strong>Algebraic Effect Types:</strong> which are semantic notations on functions and contexts
that grant a permission to <em>do</em> something.</li>
<li><strong>Algebraic Effect Handlers:</strong> which are a kind of typed control-flow
primitive which allows people to define their own versions of <code>async/.await</code>,
<code>try..catch</code>, and <code>yield</code>.</li>
</ul>
<p>A lot of languages which have effects provide both effect types and effect
handlers. These can be used together, but they are in fact distinct features. In
this talk we'll only be discussing effect types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn meow(self) {}
pub const unsafe fn meow() {}
<span class="boring">}
</span></code></pre></pre>
<p>What we've been calling &quot;effects&quot; in this talk so far have in fact been <em>effect
types</em>. Rust hasn't historically called them this, and I believe that's probably
why effect generics weren't on our radar until recently. But it turns out that
reinterpreting some of our keywords as effect types actually makes perfect
sense, and provides us with a strong theoretical framework for how to reason
about them.</p>
<p>We also have <code>unsafe</code> which allows you to call <code>unsafe</code> functions. The unstable
try-block feature which doesn't require you to <code>Ok</code>-wrap return types. The
unstable generator closure syntax which gives you access to the <code>yield</code> keyword.
And of course the <code>const</code> keyword which allows you evaluate code at
compile-time.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async { async_fn().await }; // async effect
unsafe { unsafe_fn() };     // unsafe effect
const { const_fn() };       // const effect
try { try_fn()? };          // try effect (unstable)
|| { yield my_type };       // generator effect (unstable)
<span class="boring">}
</span></code></pre></pre>
<p>In Rust we currently have five different effects: <code>async</code>, <code>unsafe</code>, <code>const</code>,
<code>try</code>, and generators. All six of these are in various stages of completion. For
example: async Rust has functions and blocks, but no iterators or drop. Const
doesn't have access to traits yet. Unsafe functions can't be lowered to <code>Fn</code>
traits. Try does have the <code>?</code> operator, but try blocks are unstable. And
generators are entirely unstable; we only have the <code>Iterator</code> trait.</p>
<p>Some of these effects are what folks on the lang team have started calling
&quot;carried&quot;. Those are effects which will desugar to an actual type in the type
system. For example when you write <code>async fn</code>, the return type will desugar to
an <code>impl Future</code>.</p>
<p>Some other effects are what we're calling: <em>&quot;uncarried&quot;</em>. These effects don't desugar
to any types in the type system, but serve only as a way to communicate
information back to the compiler. This is for example <code>const</code> or <code>unsafe</code>. While
we do check that the effects are used correctly, they don't end up being lowered
to actual types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = try async { .. };
<span class="boring">}
</span></code></pre></pre>
<pre><code>1. -&gt; impl Future&lt;Output = Result&lt;T, E&gt;&gt;
2. -&gt; Result&lt;impl Future&lt;Output = T&gt;, E&gt;
</code></pre>
<p>When we talk about carried effects, effect composition becomes important. Take
for example &quot;async&quot; and &quot;try&quot; together. If we have a function which has both?
What should the resulting type be? A future of Result? Or a Result containing a
Future?</p>
<p>Effects on functions are order-independent <em>sets</em>. While Rust currently does
require you declare effects in a specific order, carried effects themselves can
only be composed in one way. When we stabilized <code>async/.await</code>, we decided that
if an async function returned a Result, that should always return an <code>impl Future</code> of <code>Result</code>.  And because effects are <em>sets</em> and not dependent on
ordering, we can define the way carried effects should compose as part of the
language.</p>
<p>People can still opt-out from the built-in composition rules by manually writing
function signatures. But this is rare, and for the overwhelming majority of uses
the built-in composition rules will be the right choice.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn meow() {}  // maybe-const
const {}            // always-const
<span class="boring">}
</span></code></pre></pre>
<p>The <code>const</code> effect is a bit different from the other effects. <code>const</code> blocks are
<em>always</em> evaluated during compilation. While <code>const</code> functions merely <em>can</em> be
evaluated during during compilation. It's perfectly fine to call them at runtime
too. This means that when we write <code>const fn</code>, we're already writing
effect-generics. This mechanism is the reason why we've gradually been able to
introduce const into the stdlib in a backwards-compatible way.</p>
<p>Const is also a bit strange in that among other things it disallows access to
the host runtime, it can't allocate, and it can't access globals. This feels
different from effects like say, <code>async</code>, which only allow you to do more
things.</p>
<table><thead><tr><th>effect set</th><th>can access</th><th>cannot access</th></tr></thead><tbody>
<tr><td>std rust</td><td>non-termination, unwinding, non-determinism, statics, runtime heap, host APIs</td><td>N/A</td></tr>
<tr><td>alloc</td><td>non-termination, unwinding, non-determinism, globals, runtime heap</td><td>host APIs</td></tr>
<tr><td>core</td><td>non-termination, unwinding, non-determinism, globals</td><td>runtime heap, host APIs</td></tr>
<tr><td>const</td><td>non-termination, unwinding</td><td>non-determinism, globals, runtime heap, host APIs</td></tr>
</tbody></table>
<p>What's missing from this picture is that all functions in Rust carry an implicit
set of effects. Including some effects we can't directly name yet. When we write
<code>const</code> functions, our functions have a different set of effects, than if we
write <code>no_std</code> functions, which again are different from regular &quot;std&quot; rust
functions.</p>
<p>The right way of thinking about const, std, etc. is as adding a different
effects to the empty set of effects. If we start from zero, then all effects are
merely additive. They just add up to different numbers.</p>
<p>Unfortunately in Rust we can't yet name the empty set of effects. In effect
theory this is called the &quot;total effect&quot;. And some languages such as Koka do
support the &quot;total&quot; effect. In fact, Koka's lead developer has estimated that
around 70% of a typical Koka program can be total. Which begs the question: if
we could express the total effect in Rust, could we see similar numbers?</p>
<h2 id="stage-iii-more-effects"><a class="header" href="#stage-iii-more-effects">Stage III: More Effects</a></h2>
<p>So far we've only talked about how we could finish the work on existing effects
such as <code>const</code> and <code>async</code>. But one nice thing of effect generics is that they
would not only allow us to finish our ongoing effects work. It would also lower
the cost of introducing <em>new</em> effects to the language.</p>
<p>Which opens up the question: if we could add more effects, which effects might
make sense to add? The obvious ones would be to actually finish adding <code>try</code> and
generator functions. But beyond that, there are some interesting effects we
could explore. For brevity I'll only discuss what these features are, and not
show code examples.</p>
<ul>
<li><strong>no-divergence</strong>: guarantees that a function cannot loop indefinitely,
opening up the ability to perform static runtime-cost analysis.</li>
<li><strong>no-panic</strong>: guarantees a function will never produce a panic, causing
the function to unwind.</li>
<li><strong>parametricity</strong>: guarantees that a function only operates on its arguments. That
means no implicit access to statics, no global filesystem, no thread-locals.</li>
<li><strong>capability-safety</strong>: guarantees that a function is not only parametric, but can't
downcast abstract types either. Say if you get an <code>impl Read</code>, you can't reverse
it to obtain a <code>File</code>.</li>
<li><strong>destructor linearity</strong>: guarantees that <code>Drop</code> will <em>always</em> be called,
making it a safety guarantee.</li>
<li><strong>pattern types</strong>: enables functions to operate directly on variants of enums
and numbers</li>
<li><strong>must-not-move types</strong>: would be a generalization of pinning and the
pin-project system, making it a first-class language feature</li>
</ul>
<p>Though there's nothing inherently stopping us from adding any of these features
into Rust today, in order to integrate them into the stdlib without breaking
backwards-compatibility we need effect generics first.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>effect const  = diverge + panic;
effect core   = const + statics + non_determinism;
effect alloc  = core + heap;
effect std    = alloc + host_apis;
<span class="boring">}
</span></code></pre></pre>
<p>This brings us to the final part of the design space: effect aliases. If we keep
adding effects it's very easy to eventually reach into a situation where we have
our own version of &quot;public static void main&quot;.</p>
<p>In order to mitigate that it would instead be great if we could name specific
sets of effects. In a way we've already done that, where <code>const</code> represents &quot;may
loop forever&quot; and &quot;may panic&quot;. If we actually had &quot;may loop forever&quot; and &quot;may
panic&quot; as built-in effects, then we could redefine <code>const</code> as an alias to those.</p>
<p>Fundamentally this doesn't change anything we've talked about so far. It's just
that this would syntactically be a lot more pleasant to work with. So if we ever
reach a state where we have effect generics and we want notice we maybe have one
too many notation in front of our functions, it may be time for us to start
looking into this more seriously.</p>
<h2 id="outro"><a class="header" href="#outro">Outro</a></h2>
<p>Rust already includes effect types such as async, const, try, and unsafe.
Because we can't be generic over effect types yet, we usually have to choose
between either duplicating code, or just not addressing the use case. And this
makes for a language which feels incredibly rough once you start using effects.
Effect generics provide us with a way to be generic over effects, and we've
shown they can be implemented today as mostly as syntax sugar over
const-generics.</p>
<p>We're currently in the process of formalizing the effect generic work via the
A-Mir-Formality. MIR Formality is an in-progress formal model of Rust's type
system. Because effect generics are relatively straight forward but have
far-reaching consequences for the type system, it is an ideal candidate to test
as part of the formal model.</p>
<p>In parallel the const WG has also begun refactoring the way const functions are
checked in the compiler. In the past const-checking happened right before borrow
checking at the MIR level. In the new system const-checking will happen much
sooner, at the HIR level. This will not only make the code more maintainable, it
will also be generalizable to more effects if needed.</p>
<p>Once both the formal modeling and compiler refactorings conclude, we'll begin
drafting an RFC for effect-generic trait definitions. We expect this to happen
sometime in 2024.</p>
<p>And that's the end of this talk. Thank you so much for being with me all the way
to the end. None of the work in this talk would have been possible without the
following people:</p>
<ul>
<li>Oliver Scherer (AWS)</li>
<li>Eric Holk (Microsoft)</li>
<li>Niko Matsakis (AWS)</li>
<li>Daan Leijen (Microsoft)</li>
</ul>
<p>Thank you!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-keyword-generics-charter"><a class="header" href="#-keyword-generics-charter">üìú keyword generics Charter</a></h1>
<p>One of Rust's defining features is the ability to write functions which are
<em>generic</em> over their input types. That allows us to write a function once,
leaving it up to the compiler to generate the right implementations for us.</p>
<p>When we introduce a new keyword for something which used to be a trait, we not
only gain new functionality - we also lose the ability to be generic over that
keyword. This proposal seeks to change that by introducing keyword generics: the
ability to be generic over specific keywords.</p>
<p>This proposal is scoped to the <code>const</code> and <code>async</code> keywords only, but is designed
to be leveraged by other keywords as well in the future. Keywords are valuable,
generics are valuable, users of Rust shouldn't have to choose between the two.</p>
<!--
 Provide an introduction summarising the goals and motivation behind your
 initiative.
-->
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>We're in the process of adding new features to Rust. The Const WG is creating an
extension to Rust which enables arbitrary computation at compile time.
While the Async WG is in the process of adding capabilities for asynchronous
computation. We've noticed that both these efforts have a lot in common, and may
in fact require similar solutions. This document describes a framework for
thinking about these language features, describes their individual needs, and
makes the case that we should be considering a generalized language design for
&quot;keywords&quot; (aka &quot;definitely not effects&quot;), so that we can ensure that the Rust
language and standard library remain consistent in the face of extensions.</p>
<h2 id="a-broad-perspective-on-language-extensions"><a class="header" href="#a-broad-perspective-on-language-extensions">A broad perspective on language extensions</a></h2>
<p><code>const fn</code> and <code>async fn</code> are similar language extensions, but the way they
extend the language is different:</p>
<ul>
<li><code>const fn</code> creates a <em>subset</em> of &quot;base Rust&quot;, enabling functions to be
executed during compilation. <code>const</code> functions can be executed in &quot;base&quot;
contexts, while the other way around isn't possible.</li>
<li><code>async fn</code> creates a <em>superset</em> of &quot;base Rust&quot;, enabling functions to be
executed asynchronously. <code>async</code> types cannot be executed in &quot;base&quot; contexts
<sup class="footnote-reference"><a href="#bridge">1</a></sup>, but &quot;base&quot; in <code>async</code> contexts <em>is</em> possible.</li>
</ul>
<div class="footnote-definition" id="bridge"><sup class="footnote-definition-label">1</sup>
<p>In order to bridge async and non-async Rust, functionality such as
<code>thread::block_on</code> or <code>async fn</code> must be used, which runs a future to completion
from a synchronous context. <code>const</code> Rust does not require such a bridge, since
the difference in contexts is &quot;compile time&quot; and &quot;run-time&quot;.</p>
</div>
<pre><code>                      +---------------------------+                               
                      | +-----------------------+ |     Compute values:
                      | | +-------------------+ | |     - types
                      | | |                   | | |     - numbers
                      | | |    const Rust     |-------{ - functions               
                      | | |                   | | |     - control flow            
 Access to the host:  | | +-------------------+ | |     - traits (planned)                 
 - networking         | |                       | |     - containers (planned)
 - filesystem  }--------|      &quot;base&quot; Rust      | |                               
 - threads            | |                       | |                               
 - system time        | +-----------------------+ |     
                      |                           |     Control over execution:      
                      |         async Rust        |---{ - ad-hoc concurrency      
                      |                           |     - ad-hoc cancellation     
                      +---------------------------+     - ad-hoc pausing/resumption

</code></pre>
<p>In terms of standard library these relationships also mirror each other. &quot;Base&quot;
Rust will want to do everything during runtime what <code>const</code> rust can do, but in
addition to that also things like network and filesystem IO. Async Rust will in
turn want to do everything &quot;base&quot; Rust can do, but in addition to that will also
want to introduce methods for ad-hoc concurrency, cancellation, and execution
control. It will also want to do things which are blocking in &quot;base&quot; Rust as
non-blocking in async Rust.</p>
<p>And it doesn't stop with <code>const</code> and <code>async</code> Rust; it's not hard to imagine that
other annotations for &quot;can this panic&quot;, &quot;can this return an error&quot;, &quot;can this
yield values&quot; may want to exist as well. All of which would present extensions
to the &quot;base&quot; Rust language, which would need to be introduced in a way which
keeps it feeling like a single language - instead of several disjoint languages
in a trenchcoat.</p>
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/yoshuawuyts">Yosh Wuyts</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/oli-obk">Oli Scherer</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">Liaison</a></td><td><a href="https://github.com/nikomatsakis">Niko Matsakis?</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-evaluation"><a class="header" href="#-evaluation">üî¨ Evaluation</a></h1>
<blockquote>
<p>The <em>evaluation</em> surveys the various design approaches that are under consideration.
It is not required for all initiatives, only those that begin with a problem statement
but without a clear picture of the best solution. Often the evaluation will refer to topics
in the <a href="evaluation/./design-discussions.html">design-discussions</a> for more detailed consideration.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: (fill me in: <code>name-of-design</code>)</li>
<li>Proposed by: [@name](link to github profile)</li>
<li>Original proposal (optional): (url)</li>
</ul>
<h1 id="design"><a class="header" href="#design">Design</a></h1>
<!-- Please fill out the snippets labeled with "fill me in". If there are any
other examples you want to show, please feel free to append more.-->
<h2 id="base-reference"><a class="header" href="#base-reference">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async"><a class="header" href="#always-async">always async</a></h2>
<!-- A variant where all items are always `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fill me in
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async"><a class="header" href="#maybe-async">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fill me in
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords"><a class="header" href="#generic-over-all-modifier-keywords">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fill me in
<span class="boring">}
</span></code></pre></pre>
<h1 id="notes"><a class="header" href="#notes">Notes</a></h1>
<!-- Add additional notes, context, and thoughts you want to share about your design
here -->
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: <code>attribute based effects</code></li>
<li>Proposed by: <a href="https://github.com/oli-obk">@oli-obk</a></li>
<li>Original proposal (optional): (url)</li>
</ul>
<h1 id="design-1"><a class="header" href="#design-1">Design</a></h1>
<p>Use function and trait attributes to make a function/trait have effect-like behaviour
instead of adding new syntax. There's still some new syntax in trait bounds, but these are
removed by the attribute at attribute expansion time.</p>
<p>This is experimentally being built with a proc macro in https://github.com/yoshuawuyts/maybe-async-channel.</p>
<h2 id="base-reference-1"><a class="header" href="#base-reference-1">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async-1"><a class="header" href="#always-async-1">always async</a></h2>
<!-- A variant where all items are always `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async]
pub trait Iterator {
    type Item;
    #[async]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
#[async]
fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: async Iterator&lt;Item = T&gt; + Sized,
    P: async FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async-1"><a class="header" href="#maybe-async-1">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe_async]
pub trait Iterator {
    type Item;
    #[maybe_async]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
#[maybe_async]
fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: async Iterator&lt;Item = T&gt; + Sized,
    P: async FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords-1"><a class="header" href="#generic-over-all-modifier-keywords-1">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[effect]
pub trait Iterator {
    type Item;
    #[effect]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
#[effect]
fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: effect Iterator&lt;Item = T&gt; + Sized,
    P: effect FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h1 id="notes-1"><a class="header" href="#notes-1">Notes</a></h1>
<!-- Add additional notes, context, and thoughts you want to share about your design
here -->
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: <code>const bool-like effects</code></li>
<li>Proposed by: <a href="https://github.com/sayaks">@Lili Zoey</a></li>
<li>Original proposal: <a href="https://github.com/rust-lang/keyword-generics-initiative/issues/10#issuecomment-1445263558">comment</a></li>
</ul>
<h1 id="design-2"><a class="header" href="#design-2">Design</a></h1>
<!-- Please fill out the snippets labeled with "fill me in". If there are any
other examples you want to show, please feel free to append more.-->
<h2 id="base-reference-2"><a class="header" href="#base-reference-2">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async-2"><a class="header" href="#always-async-2">always async</a></h2>
<!-- A variant where all items are always `async` -->
<p>In all 
The methods on the trait are assumed async because the trait is <code>async</code>.</p>
<p>Variation A:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    !async fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub async fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: async FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>Variation B. Using an &quot;<code>effect</code>-generics&quot; notation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect async&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint&lt;effect !async&gt;(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect async&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut&lt;effect async&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>Variation C. Using an <code>effect</code>-notation in <code>where</code>-bounds:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator
where
    effect async
{
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)
    where
        effect !async;
}

pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut&lt;effect async&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async-2"><a class="header" href="#maybe-async-2">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<p>For all variations the use of <code>&lt;effect async = A&gt;</code> on <code>fn next</code> is elided.</p>
<p>Variation A. Using an <code>effect A: async</code> + <code>!async fn</code> in the trait definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: async&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    !async fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect A: async&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T, effect async = A&gt; + Sized,
    P: FnMut&lt;effect async = A&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>Variation B. Using <code>effect A: async</code> + <code>effect! async</code> in the trait definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: async&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint&lt;effect !async&gt;(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect A: async&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T, effect async = A&gt; + Sized,
    P: FnMut&lt;effect async = A&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>Variation C. Using <code>effect A: async</code> + <code>where effect !async</code> notation.  If we'd
instead written <code>where A = !async</code>, the <code>size_hint</code> method would only exist if
the context was not async. It instead now exists as not async in all contexts:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: async&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;)
    where
        effect !async;
}

pub fn find&lt;I, T, P, effect A: async&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T, effect async = A&gt; + Sized,
    P: FnMut&lt;effect async = A&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords-2"><a class="header" href="#generic-over-all-modifier-keywords-2">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: for&lt;effect&gt;&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    !async fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect A: for&lt;effect&gt;&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T, for&lt;effect&gt; = A&gt; + Sized,
    P: FnMut&lt;for&lt;effect&gt; = A&gt;(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p><a href="evaluation/syntax/const-bool-like-effects.html#foreffect-bounds-and-traits">See also</a></p>
<h1 id="notes-2"><a class="header" href="#notes-2">Notes</a></h1>
<p><code>!async fn foo</code> could be <code>sync fn foo</code> or omitted entirely in favor of only having <code>fn foo&lt;effect !async&gt;</code>. It is also a question if <em>all</em> effects should allow for <code>effect fn foo</code> syntax.</p>
<p><code>for&lt;effect&gt;</code> should maybe be made more special-looking since it behaves quite differently from other generic effect variables.</p>
<p>The exact syntax of <code>effect A: E</code> and <code>effect E = A</code> for declaring a generic and specifying a bound for an effect could maybe be made different. </p>
<p>It might be easier to implement specialization for specifically effect-generics, as they are rather simple, effectively just being bools, and there not being any lifetime parameters on them.</p>
<h2 id="some-nice-things-about-the-syntax"><a class="header" href="#some-nice-things-about-the-syntax">Some nice things about the syntax</a></h2>
<h3 id="specific-behavior"><a class="header" href="#specific-behavior">Specific behavior</a></h3>
<p>To make a function have specific behavior in the case where an effect is or is not true, we could do this:</p>
<pre><code class="language-rs">fn foo&lt;effect A: async&gt;() {
    if A {
        // do stuff when foo is async
    } else {
        // do stuff when foo is not async
    }
}
</code></pre>
<h3 id="impl-blocks"><a class="header" href="#impl-blocks">Impl blocks</a></h3>
<p>impl blocks could look very similar to any other generics.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;effect A: async&gt; SomeTrait&lt;effect async = A&gt; MyGenericType { ... }
impl SomeTrait&lt;effect async&gt; MyAsyncType { ... }
impl SomeTrait&lt;effect !async&gt; MySyncType { ... }
<span class="boring">}
</span></code></pre></pre>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>We can add effects to generics like <code>&lt;effect A: E&gt;</code>, and create bounds for the effects of types by doing <code>effect E = A</code> in the <code>&lt;..&gt;</code> list or the where-clause.</p>
<p>The basic syntax is that <code>effect async = true</code> means the type is async, whereas <code>effect async = false</code> means it is not.</p>
<p>For convenience we'd let <code>effect async</code> be the same as <code>effect async = true</code> and <code>effect !async</code> be the same as <code>effect async = false</code>.</p>
<p><code>async fn foo</code> would be syntactic sugar for <code>fn foo&lt;effect async = true&gt;</code>. and similar for other effects.</p>
<p>So as an example, here are some equivalent ways of writing an async function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T, O, const N: usize, effect async = true&gt;(...) {...}
fn foo&lt;T, O, const N: usize, effect async&gt;(...) {...}
async fn foo&lt;T, O, const N: usize&gt;(...) {...}
fn foo&lt;T, O, const N: usize&gt;(...) where effect async {...}
<span class="boring">}
</span></code></pre></pre>
<p>Every effect has a default value, and if there is no bound on the type for that specific effect it is assumed to have its default value. So the function above, having no bound on <code>const</code>, would be assumed not-const.</p>
<p>This could be explicitly stated like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo&lt;T, O, const N: usize&gt;(...) where effect !const {...}
<span class="boring">}
</span></code></pre></pre>
<p>However this would be unneccesary.</p>
<p>If a type has only one generic for an effect, and no other bounds for that effect. It is assumed to have the same bound as that one generic. Meaning the following are equivalent ways of making a function generic over <code>async</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T, O, const N: usize, effect A: async&gt;foo(...) where effect async = A {...}
fn foo&lt;T, O, const N: usize, effect A: async&gt;foo(...) {...}
<span class="boring">}
</span></code></pre></pre>
<p>However if there are multiple generics, we'd need to explicitly state what the bound should be for the type itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T, O, const N: usize, effect A: async, effect B: async&gt;foo(...) where effect async = A | B {...}
<span class="boring">}
</span></code></pre></pre>
<p>This would mean that <code>foo</code> is async if either <code>A</code> is true or <code>B</code> is true. We could also use <code>A + B</code> if wanted it to be async whenever both are true.</p>
<p>Declaring an type to have/not have an effect different from the default value might change the type. For instance 
<code>fn foo&lt;effect async&gt;() -&gt; T</code> would become <code>foo() -&gt; Future&lt;Output = T&gt;</code>.</p>
<p>Every generic effect variable (except <code>for&lt;effect&gt;</code>) is also like a constant boolean value, which is true whenever the type is in a context where it has that effect, and false otherwise.</p>
<p>In traits, the items are assumed to have the same effect bounds as the trait itself. But this can be overridden using specific bounds for that item.</p>
<p>For instance</p>
<pre><code class="language-rs">trait Read&lt;effect A: async&gt; {
    // This function is now generic over async
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    // or equivalently
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; where effect async = A;

    // This function is now always async
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
    // or equivalently
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; where effect async;

    // This function now only exists when the trait is async
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; where A;
}
</code></pre>
<p>This also shows that unlike normal <code>const _: bool</code> we can actually use whether the generic effects are <code>true</code>/<code>false</code> in the where-clause.</p>
<h3 id="foreffect"><a class="header" href="#foreffect"><code>for&lt;effect&gt;</code></a></h3>
<p><code>for&lt;effect&gt;</code> is a universal effect bound that allows you to place bounds on all the effects of a type. Adding a <code>effect A: for&lt;effect&gt;</code> makes <code>A</code> a generic variable that ranges over every effect. This means its value is no longer a simple <code>true</code>/<code>false</code> and so can't be used bare in where-clauses.</p>
<p>If another bound is added that is more specific, that bound will limit the possible values of <code>A</code> as well. Meaning that if you have <code>&lt;effect A: for&lt;effect&gt;, effect async&gt;</code>, we would have the type be generic over every effect except async. And the type would always be async.</p>
<p>For instance, to make a function generic over all effects except const we'd write</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;effect A: for&lt;effect&gt;&gt;(...) where effect async {...}
<span class="boring">}
</span></code></pre></pre>
<p>To place bounds on every effect we write <code>for&lt;effect&gt; = A</code> where <code>A</code> is some bound. This should probably be limited somewhat to avoid people writing code that can very easily break. Consider for instance <code>for&lt;effect&gt; = true</code>, which would declare something as having <em>every</em> effect. This could lead to breakage if a new effect is added and the function isn't compatible with this new effect. The main uses of placing bounds on <code>for&lt;effect&gt;</code> would to use it with other universal bounds.</p>
<p>Using <code>A + B</code> and <code>A | B</code> bounds for universal bounds may also be problematic, as it may not always be possible to create any meaningful code that is generic in all those cases. So we may have to either disallow having multiple generic universal bounds, or have the compiler automatically infer the relationship between effects.</p>
<p>For instance</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;O, F1, F2, effect A: for&lt;effect&gt;, effect B: for&lt;effect&gt;&gt;(closure1: F1, closure2: F2) -&gt; O
where
    F1: FnMut&lt;for&lt;effect&gt; = A&gt;() -&gt; O,
    F2: FnMut&lt;for&lt;effect&gt; = B&gt;() -&gt; O
{ ... }
<span class="boring">}
</span></code></pre></pre>
<p>Here it is unclear when <code>foo</code> should be async and const. For instance, usually a function is <code>async</code> if there is <em>any</em> async code in the function. Whereas it is <code>const</code> if <em>all</em> the code is <code>const</code>.</p>
<p>I'm not entirely sure if this is best left up to the compiler to infer, it should be disallowed, or if the user must specify the bounds on every specific effect they may use.</p>
<p>However if the compiler infers it all, we could still specify specific relationships, like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;O, F1, F2, effect A: for&lt;effect&gt;, effect B: for&lt;effect&gt;&gt;(closure1: F1, closure2: F2) -&gt; O
where
    effect async = A + B,
    F1: FnMut&lt;for&lt;effect&gt; = A&gt;() -&gt; O,
    F2: FnMut&lt;for&lt;effect&gt; = B&gt;() -&gt; O
{ ... }
<span class="boring">}
</span></code></pre></pre>
<p>To make this function async only if <em>both</em> <code>A</code> and <code>B</code> are async (or rather <code>async = true</code> in both sets <code>A</code> and <code>B</code>).</p>
<h3 id="semi-formal-description"><a class="header" href="#semi-formal-description">semi-formal description</a></h3>
<details>
<summary>Syntax</summary>
There's a new kind of generic called effect-generics. For any given type, that effect may be `true` meaning the type has that effect, or it can be `false` meaning the type does not have that effect. 
<p>We can make a type generic over an effect by adding <code>effect A: E</code>, where <code>A</code> is a generic variable and <code>E</code> is an effect.</p>
<p>An effect bound is one of: <code>true</code>, <code>false</code>, <code>default</code>, <code>A</code>, <code>B1 + B2</code>, <code>B1 | B2</code>, <code>!B1</code>. Where <code>A</code> is a generic variable, <code>B1</code> and <code>B2</code> are effect bounds.</p>
<p>An effect is either: the name of an effect, a generic variable, or <code>for&lt;effect&gt;</code></p>
<p>To specify that a type must fit some effect bound we write <code>effect E = A</code>, where <code>E</code> is an effect and <code>A</code> is an effect bound, either in the <code>&lt;..&gt;</code> list or in the where-clause.</p>
</details>
<details>
<summary>Semantics</summary>
<ul>
<li><code>effect E = true</code> means &quot;has the effect <code>E</code>&quot;</li>
<li><code>effect E = false</code> means &quot;does not have the effect <code>E</code>&quot;</li>
<li><code>effect E = default</code> means &quot;has the effect <code>E</code> if the default for the effect is true&quot;</li>
<li><code>effect E = A</code> where <code>A</code> is a generic variable, means &quot;has the effect <code>E</code> if <code>A</code> is true&quot;</li>
<li><code>effect E = B1 + B2</code> means &quot;has the effect <code>E</code> if the bounds <code>B1</code> and <code>B2</code> are true&quot;</li>
<li><code>effect E = B1 | B2</code> means &quot;has the effect <code>E</code> if the bounds <code>B1</code> or <code>B2</code> are true&quot;</li>
<li><code>effect E = !B</code> means &quot;has the effect <code>E</code> if the bound <code>B</code> is false&quot;</li>
<li><code>effect for&lt;effect&gt; = B</code> means &quot;the effect bound <code>B</code> applies to every effect&quot;</li>
<li><code>effect A: E</code> means &quot;<code>A</code> is a generic variable corresponding to the effect <code>E</code>&quot;</li>
</ul>
</details>
<h2 id="foreffect-bounds-and-traits"><a class="header" href="#foreffect-bounds-and-traits"><code>for&lt;effect&gt;</code> bounds and traits</a></h2>
<p>In the <a href="evaluation/syntax/const-bool-like-effects.html#generic-over-all-modifier-keywords">generic over all keywords</a> case we'd have that <code>size_hint</code> is generic over all effects except async. So it might be better to make such universal bounds not automatically apply to all items in a trait.</p>
<p>In that case we'd have</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: for&lt;effect&gt;&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; where for&lt;effect&gt; = A;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively we could have an opt-out syntax, which would look something like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect A: for&lt;effect&gt;&gt; {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) where for&lt;effect&gt; = default;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: <code>effect-as-a-clause</code></li>
<li>Proposed by: <a href="https://github.com/mominul">@mominul</a> <a href="https://github.com/satvikpendem">@satvikpendem</a></li>
<li>Original proposal (optional): (https://github.com/rust-lang/keyword-generics-initiative/issues/14)</li>
</ul>
<h1 id="design-3"><a class="header" href="#design-3">Design</a></h1>
<p>We want to propose the usage of the <code>effect</code> clause to achieve operation genericity, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;
    effect
        async;

    fn read_to_string(&amp;mut self, buf: &amp;mut String) -&gt; Result&lt;usize&gt; 
    effect
        async
    { .. }
}

/// Function to read from the file into a string which may exhibit async or const effect
fn read_to_string(path: &amp;str) -&gt; io::Result&lt;String&gt;
effect
       async, const 
{
    let mut string = String::new();

    // We can be conditional over the context the function has been called from, 
    // only when the function declaration has the `effect` clause
    if async || !async {
        let mut file = File::open(&quot;foo.txt&quot;)?; // File implements Read
        // Because `read_to_string` is also an `effect` function that may or may not exhibit 
        // async-ness par the declaration, we can use it on both contexts (async/sync) 
        // we are placing the condition on.
        file.read_to_string(&amp;mut string)?;  // .await will be inferred.   
    } else { // must be const
        // As the `read_to_string` doesn't exhibit const-ness, we'll need to handle it ourselves.
        string = include_str!(path).to_string();
    }

    Ok(string)
}

/// A normal function
fn read() {
    let data = read_to_string(&quot;hello.txt&quot;).unwrap();
}

/// A async function
async fn read() {
    let data = read_to_string(&quot;hello.txt&quot;).await.unwrap();
}

/// A const function
const fn read() {
    let data = read_to_string(&quot;hello.txt&quot;).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>So in a nutshell, a function declaration with an <code>effect</code> clause is a special type of function that <strong>may</strong> or <strong>may not</strong> exhibit async or const behavior(effect) and it <strong>depends on the context of the function being called from</strong> and we can <strong>execute a different piece of code according to the context</strong> from the function was called from too (like the <code>const_eval_select</code>, resolves <a href="https://github.com/rust-lang/keyword-generics-initiative/issues/6">#6</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function() -&gt; Result&lt;()&gt;
effect
    async, const
{
    // ...
    if async {
        // code for handling stuff asynchronously
    } else if const {
        // code for handling stuff `const`-way
    else {
        // code for handling stuff synchronously
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="base-reference-3"><a class="header" href="#base-reference-3">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async-3"><a class="header" href="#always-async-3">always async</a></h2>
<!-- A variant where all items are always `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    async fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub async fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: async FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async-3"><a class="header" href="#maybe-async-3">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    effect async;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool effect async;
effect
    async
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords-3"><a class="header" href="#generic-over-all-modifier-keywords-3">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    effect async, const;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool effect async, const;
effect
    async, const
<span class="boring">}
</span></code></pre></pre>
<h1 id="notes-3"><a class="header" href="#notes-3">Notes</a></h1>
<!-- Add additional notes, context, and thoughts you want to share about your design
here -->
<p>We can introduce <code>maybe</code> keyword instead of <code>effect</code> if it seems more appropriate terminology for the semantics described in this proposal.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: <code>postfix-question-mark</code></li>
<li>Proposed by: <a href="https://github.com/tvallotton">@tvallotton</a></li>
</ul>
<h1 id="design-4"><a class="header" href="#design-4">Design</a></h1>
<h2 id="base-reference-4"><a class="header" href="#base-reference-4">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait async? Iterator {
    type Item;
    async? fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub async? fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: async? Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async-4"><a class="header" href="#always-async-4">always async</a></h2>
<!-- A variant where all items are always `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An adaptation of `Iterator::find` to a free-function
pub async fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: async Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async-4"><a class="header" href="#maybe-async-4">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async? fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: async? Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords-4"><a class="header" href="#generic-over-all-modifier-keywords-4">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait effect Iterator {
    type Item;
    effect fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="notes-4"><a class="header" href="#notes-4">Notes</a></h1>
<p>This is just a postfix version of the originally proposed syntax.
This should appear more familiar, as the question mark is normally used at the end of a 
sentence, not at the beginning, and it looks similar to typescripts nullable types. 
it also makes generic references more legible <code>&amp;mut? T</code> vs <code>&amp;?mut T</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Name: <code>where effect bounds</code></li>
<li>Proposed by: <a href="https://github.com/CaioOliveira793">@CaioOliveira793</a></li>
<li>Original proposal: None</li>
</ul>
<h1 id="design-5"><a class="header" href="#design-5">Design</a></h1>
<p>This syntax focus on being simple and recognizable rust code, with the possibility to incrementally extend the capabilities that keyewords generic may provide.</p>
<h2 id="base-reference-5"><a class="header" href="#base-reference-5">base (reference)</a></h2>
<!-- This is the snippet which is being translated to various scenarios we're
translating from. Please keep this as-is, so we can reference it later.-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trimmed-down version of the `std::Iterator` trait.
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

/// An adaptation of `Iterator::find` to a free-function
pub fn find&lt;I, T, P&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    I: Iterator&lt;Item = T&gt; + Sized,
    P: FnMut(&amp;T) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<h2 id="always-async-5"><a class="header" href="#always-async-5">always async</a></h2>
<!-- A variant where all items are always `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect&gt;
where
    effect: async
{
    type Item;

    // opt-in for a always async effect
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        effect: async;

    // the size_hint is left unchanged, since the effect is opt-in
    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    effect: async,
    I: Iterator&lt;Item = T&gt; + Sized,
    &lt;I as Iterator&gt;::effect: async,
    P: FnMut(&amp;T) -&gt; bool,
    &lt;P as FnMut&gt;::effect: async;
<span class="boring">}
</span></code></pre></pre>
<h2 id="maybe-async-5"><a class="header" href="#maybe-async-5">maybe async</a></h2>
<!-- A variant where all items are generic over `async` -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect&gt;
where
    effect: ?async
{
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        effect: ?async;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    effect: ?async,
    I: Iterator&lt;Item = T&gt; + Sized,
    &lt;I as Iterator&gt;::effect: ?async,
    P: FnMut(&amp;T) -&gt; bool,
    &lt;P as FnMut&gt;::effect: ?async;
<span class="boring">}
</span></code></pre></pre>
<h2 id="generic-over-all-modifier-keywords-5"><a class="header" href="#generic-over-all-modifier-keywords-5">generic over all modifier keywords</a></h2>
<!-- A variant where all items are generic over all modifier keywords (e.g.
`async`, `const`, `gen`, etc.) -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;effect&gt;
where
    // LIMITATION: in order to be generic over all keywords the effect clause must specify all keywords available
    effect: ?async + ?const
{
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    where
        effect: ?async + ?const;

    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;);
}

pub fn find&lt;I, T, P, effect&gt;(iter: &amp;mut I, predicate: P) -&gt; Option&lt;T&gt;
where
    effect: ?async + ?const,
    I: Iterator&lt;Item = T&gt; + Sized,
    &lt;I as Iterator&gt;::effect: ?async + ?const,
    P: FnMut(&amp;T) -&gt; bool,
    &lt;P as FnMut&gt;::effect: ?async + ?const;
<span class="boring">}
</span></code></pre></pre>
<h1 id="notes-5"><a class="header" href="#notes-5">Notes</a></h1>
<h2 id="trait-effect-bounds"><a class="header" href="#trait-effect-bounds">Trait effect bounds</a></h2>
<p>The syntax for specifying the effect of a trait implemented by some generic argument <code>&lt;I as Iterator&gt;::effect: const</code> could be different</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>I: Iterator&lt;effect = ?async + ?const&gt;

// or

// Associated type bounds [RFC 2289](https://github.com/rust-lang/rfcs/blob/master/text/2289-associated-type-bounds.md)
I: Iterator&lt;effect: ?async + ?const&gt;
<span class="boring">}
</span></code></pre></pre>
<p>The current way mimics how associated types are bound</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_iter&lt;I, effect&gt;(iter: I)
where
    effect: ?async,
    I: Iterator,
    &lt;I as Iterator&gt;::Item: Display,
    &lt;I as Iterator&gt;::effect: ?async;
<span class="boring">}
</span></code></pre></pre>
<h2 id="explicit-generic-over-all-modifier-keywords"><a class="header" href="#explicit-generic-over-all-modifier-keywords">Explicit generic over all modifier keywords</a></h2>
<p>The syntax does not give shortans for specifying all modifiers at once. Instead, the function, trait or type should <strong>explicit bound</strong> over all keywords it could be generic.</p>
<p>Although being inconvenient to list it manually, this has some advantages over the <em>generic over all keywords available</em> syntax.</p>
<h3 id="explicit"><a class="header" href="#explicit">Explicit</a></h3>
<p>Readers does not have to remind which keywords are available that may need to be implemented in some specific way.</p>
<h3 id="backwards-compatible-to-introduce-new-keywords-in-the-language"><a class="header" href="#backwards-compatible-to-introduce-new-keywords-in-the-language">Backwards compatible to introduce new keywords in the language</a></h3>
<p>Allowing the <em>generic over all</em> means that in case a new keyword lands, all <em>complete generic</em> functions and traits may be affected by the keyword, requiring at least some considerations on the side effects.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>These are some limitations (hopefully, not yet supported features) noticed in the syntax.</p>
<h3 id="effect-sets"><a class="header" href="#effect-sets">Effect sets</a></h3>
<p>Function generic over sets of effects, limiting it to be called by <strong>only one</strong> group of effects.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute&lt;effect&lt;KernelSpace | UserSpace | PreComputed&gt;&gt;() -&gt; Response
where
    effect&lt;KernelSpace&gt;: !alloc + !panic + !async,
    effect&lt;UserSpace&gt;: alloc + ?async,
    effect&lt;PreComputed&gt;: const
{
    if effect&lt;KernelSpace&gt; {
        // ensures that in &quot;KernelSpace&quot; will not alloc, panic or run futures
    }
    if effect&lt;UserSpace&gt; {
        // allow allocations and futures
    }
    if effect&lt;PreComputed&gt; {
        // only compile-time evaluation
    }
}

fn caller1()
where
    effect: ?alloc + !panic + !async
{
    compute&lt;effect&lt;KernelSpace&gt;&gt;(); // allowed
}

fn caller2()
where
    effect: alloc + async
{
    compute&lt;effect&lt;KernelSpace&gt;&gt;(); // allowed
    compute&lt;effect&lt;UserSpace&gt;&gt;(); // allowed
}

fn caller3()
where
    effect: !alloc
{
    compute&lt;effect&lt;UserSpace&gt;&gt;(); // compiler error
}

fn caller4()
where
    effect: const
{
    compute&lt;effect&lt;PreComputed&gt;&gt;(); // allowed
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-types-and-backwards-compatibility"><a class="header" href="#pattern-types-and-backwards-compatibility">Pattern Types and Backwards Compatibility</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p><a href="https://gist.github.com/joboet/0cecbce925ee2ad1ee3e5520cec81e30">Pattern types</a>
are an in-progress proposal for Rust to add a limited form of refinement types /
liquid types to Rust via pattern the pattern notation. Take for example the
existing
<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.load"><code>AtomicBool::load</code></a>
operation. Its signature looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A boolean type which can be safely shared between threads.
struct AtomicBool { .. }

impl AtomicBool {
    /// Loads a value from the bool.
    pub fn load(&amp;self, order: Ordering) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>Atomics are part Rust's memory model, and are how we're able to share data
between threads. Depending on what we want to do with an atomic, we'll want to
give it a different
<a href="https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>
argument. <code>Ordering</code> is just an enum, which has the following variants:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
<span class="boring">}
</span></code></pre></pre>
<p>For this example it doesn't exactly matter what each of these variants are for.
But what's important is that not all variants are valid arguments for
<code>AtomicBool::load</code>. Its documentation says that <code>SeqCst</code>, <code>Acquire</code>, and
<code>Relaxed</code> are valid. But if the <code>Release</code> or <code>AcqRel</code> variants are used, it will
panic at runtime.</p>
<p>Pattern types would in theory enable us to &quot;shift-left&quot; on this, by encoding the
allowed variants directly into the function's parameters. This would encode this
invariant directly via the type system, meaning we've &quot;shifted left&quot; from a
runtime error (e.g. we need to run tests to find the bug), to a compiler error
(e.g. we need to run <code>cargo check</code> to find the bug). Using the pattern types
draft RFC, this would look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AtomicBool { .. }
impl AtomicBool {
    pub fn load(&amp;self,
        order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
    ) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="backwards-compatibility-issues"><a class="header" href="#backwards-compatibility-issues">Backwards-compatibility issues</a></h2>
<p>Moving checks from runtime to compile-time is generally considered a good thing,
as it shortens the time it takes to discover bugs. But when we use pattern types
as inputs to functions, we're <em>constraining</em> the input space from all variants
to just the legal variants. Take for example the following code, which is legal
to write today.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_wrapper(order: Ordering, bool: &amp;AtomicBool) -&gt; bool {
    bool.load(order)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code does not know about pattern types, and Rust's backwards-compatibility
guarantees require that it keeps compiling in future releases of the compiler.
That means that changing <code>AtomicBool::load</code> to require taking pattern types as
its input would be a backwards-incompatible change. So we cannot just do that.</p>
<p>One alternative would be to create a duplicate version of <code>AtomicBool</code> which
does know how to take pattern types. But duplicating code just to improve it
feels pretty bad - instead it would be nice if we could update existing
functions without it leading to breaking changes.</p>
<h2 id="resolving-the-backwards-compatibility-issues"><a class="header" href="#resolving-the-backwards-compatibility-issues">Resolving the backwards-compatibility issues</a></h2>
<p>On Zulip people have brought up the idea of using editions to resolve these
issues. That might be possible, but it would mean a clean break between code
written on an older edition, and code written on a newer edition. And while we
can leverage editions to change defaults in the language, this kind of break
feels like it would push against the intended goal of maintaining compatibility
between editions.</p>
<p>The idea underlying it seems right though: we do want some way to express
<em>modality</em> in our type system. We've already done this before using the <code>const</code>
effect. Functions tagged as <code>const</code> can be evaluated either during compilation
or at runtime. And it's backwards-compatible to take an existing runtime-only
<code>fn</code> and change it to a <code>const fn</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn meow() -&gt; &amp;'static str { &quot;meow&quot; }         // 1. The base `fn meow`
const fn meow() -&gt; &amp;'static str { &quot;meow&quot; }   // 2. Changing `meow` to a `const fn` is backwards-compatible
<span class="boring">}
</span></code></pre></pre>
<p>We could do something very similar with pattern types as well. The base
mechanism for this is to define a function which can be compiled in one of two
modes:</p>
<ol>
<li><strong>Invariants are evaluated at compile-time</strong>: The pattern types are evaluated by
the compiler according to the pattern type RFC. A compiler error is raised if
the pattern's invariants are violated.</li>
<li><strong>Invariants are evaluated at runtime</strong>: The pattern types are converted to a
sequence of assertions, and evaluated at runtime.</li>
</ol>
<p>The translation here from pattern types to runtime assertions should be fairly
mechanical. We could imagine some notation which signals that while a function
may declare pattern types, the caller has an option to either evaluate them at
runtime or during compilation. Taking our earlier <code>AtomicBool::load</code> example, we
could imagine something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AtomicBool { .. }
impl AtomicBool {
    #[maybe(pattern_types)]
    pub fn load(&amp;self,
        order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
    ) -&gt; bool { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>With this notation, all existing uses of <code>AtomicBool::load</code> would continue
working. But optionally it could be called using pattern types, which would be
evaluated at compile-time. Depending on which variant of the function is
selected, the lowering of the function would change. Desugared, this would
roughly look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Semantic lowering of `AtomicBool::load`
/// using compile-time checks
pub fn load(&amp;self,
    order: Ordering is Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed
) -&gt; bool { .. }

/// Semantic lowering of `AtomicBool::load`
/// using runtime assertions
pub fn load(&amp;self, order: Ordering) -&gt; bool {
    match order {
        order @ Ordering::SeqCst | Ordering::Acquire | Ordering::Relaxed =&gt; ..,
        order =&gt; panic!(&quot;Expected `Ordering::{{Acquire | Relaxed | SeqCst}}`, received {order}&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="todo-effect-logic-and-notation"><a class="header" href="#todo-effect-logic-and-notation">TODO: Effect logic and notation</a></h2>
<ul>
<li>in its base there are four states possible: <code>always | never | maybe | unknown</code></li>
<li><code>maybe(pattern_types)</code> is a backwards-compatibility guarantee. Having logical <code>never</code>
<ul>
<li><code>always</code> markers will put us in a position where we can eventually pull the
lever across an edition to default all functions to default to always using
pattern types - without breaking any existing code or breaking code compat.</li>
</ul>
</li>
<li>unlike <code>maybe(async)</code>, by lowering to runtime checks functions which use
<code>maybe</code> patterns should always be able to call functions which take <code>always</code>
patterns - runtime assertions using <code>match</code> will be enough to shrink
the input state to be valid from that point onward</li>
<li>the relation to subtyping and return types will affect which states of this system we may want to encode</li>
<li>unclear what the benefits are for a strictly &quot;always subtyping&quot; notation</li>
<li>in practice we'll want to independently gate the stabilization of pattern
types for existing stdlib APIs - which means we need a labeling system in the compiler</li>
</ul>
<h2 id="example-how-to-combine-effect-states-for-pattern-types"><a class="header" href="#example-how-to-combine-effect-states-for-pattern-types">Example: how to combine effect states for pattern types</a></h2>
<p><a href="https://github.com/Nadrieril">Nadrieril</a> asked the following question:</p>
<blockquote>
<p>Consider the case where crate A uses compile-time checks for pattern types and
crate B uses crate A but has no knowledge of pattern types. If we encode this
choice as an effect, we must be careful not to bubble it up (as effects do) to a
function that has no knowledge of pattern types.</p>
</blockquote>
<p>Let's write this example out. We're going to write three functions: one which
always uses pattern types, one which may use pattern types, and a function which
doesn't use pattern types. They all call each other, and that should Just Work.
Let's start with the always-pattern function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function always evaluates pattern
/// types at compile-time.
fn always(num: u8 is 0..10) {
    println!(&quot;received number {num}&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>There's nothing too special about this function: it always takes a pattern type,
meaning we can't just give it any <code>u8</code> - it needs to fit the pattern. Next,
let's write out a maybe-pattern function which either takes a pattern or a base
type - and depending on which variant is passed will either validate the input
during compilation or at runtime. This will then call into our <code>always</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function can evaluate pattern types
/// either at compile-time or at runtime
#[maybe(pattern_types)]
fn maybe(num: u8 is 0..10) {
    always(num);
}
<span class="boring">}
</span></code></pre></pre>
<p>This function either evaluates patterns during compilation or at runtime. As
we've seen before: if a pattern is evaluated at runtime, it will effectively
work as a <code>match</code> + <code>panic!</code>. As a result this function guarantees it will
<em>always</em> validate its inputs, meaning once we gain access to <code>num</code> in the
function body it will always conform to the pattern. And so we have no problem
calling the <code>always</code> function.</p>
<p>Next up is our function <code>never</code>, which never evaluates patterns. It takes a bare
<code>u8</code> with no restrictions on it whatsoever. It should be able to call the
<code>maybe</code> function without an issue.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function does not reason about pattern types
fn never(num: u8) {
    maybe(num);
}
<span class="boring">}
</span></code></pre></pre>
<p>But if we try calling the <code>always</code> function from <code>never</code>, we run into issues:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This function does not reason about pattern types
fn never(num: u8) {
    always(num);  // ‚ùå compiler error
}
<span class="boring">}
</span></code></pre></pre>
<p>This should result in a compiler error along these lines:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/lib.rs:4:12
  |
4 |     always(num);
  |     ------ ^^^^^ expected `u8 is 0..10`, found `u8`
  |     |
  |     arguments to this function are incorrect
</code></pre>
<p>The easiest way to resolve this would be to rewrite the <code>never</code> function to take
the same signature as the <code>maybe</code> function. This would insert the correct
runtime checks, contraining the value to the right pattern, which as we've seen
would make it possible to call the <code>always</code> function without any issues.</p>
<h2 id="how-widespread-is-this"><a class="header" href="#how-widespread-is-this">How widespread is this?</a></h2>
<p>Maintaining strict backwards-compatibility is primarily a concern for the Rust
stdlib. While it might be difficult to create major versions for certain other
codebases, the Rust stdlib is in the unique position that it is both used by
everyone, and we can never break existing APIs. So when we're looking at using
pattern types in input positions, it's okay to assume the Rust stdlib will be
the main user of it. To date we know of at least the following APIs which would
want to leverage pattern types as inputs:</p>
<ul>
<li><strong>number primitives</strong>: Number types in Rust expose a wide range of operations.
Take for example a look at the <a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code>
type</a>. It exposes around 20
operations per type which will panic if certain number ranges are passed.</li>
<li><strong>atomics</strong>: this is the example we've been using in this post. Atomic
operations take an <code>Ordering</code> enum, where each operation can only take certain
variants of that enum. Being able to check that during compilation would be a
boon.</li>
<li><strong>iterator methods</strong>: For example
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by"><code>Iterator::step_by</code></a>
currently takes a <code>usize</code>, but would want to take a <code>usize is 1..</code>. The same is
true for the unstable <code>Iterator::array_chunks</code> and <code>Iterator::map_windows</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-draft-rfcs"><a class="header" href="#-draft-rfcs">üìö Draft RFCs</a></h1>
<blockquote>
<p>The &quot;Draft RFCs&quot; are &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the Draft RFCs should be considered a work-in-progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>effect-generic-trait-decls</code></li>
<li>Start Date: (2024-01-01)</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/0000">rust-lang/rfcs#0000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/0000">rust-lang/rust#0000</a></li>
</ul>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>This RFC introduces Effect-Generic Trait Declarations. These are traits which
are generic over Rust's built-in effect keywords such as <code>async</code>.
Instead of defining two near-identical traits per effect, this RFC allows a
single trait to be declared which is generic over the effect. Here is a variant
of the <code>Into</code> trait which can be implemented as either async or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
trait Into&lt;T&gt;: Sized {
    #[maybe(async)]
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>Implementers can then choose whether to implement the base version or the
effectful version of the trait. If they want the base version they don't include
the <code>async</code> effect. If they want the <code>async</code> version they can include the
<code>async</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The base implementation
impl Into&lt;Loaf&gt; for Cat {    // The trait is not marked async‚Ä¶
    fn into(self) -&gt; Loaf {  // and thus neither is the method.
        self.nap()
    }
}

/// The async implementation
impl async Into&lt;AsyncLoaf&gt; for AsyncCat {  // The trait is marked async‚Ä¶
    async fn into(self) -&gt; AsyncLoaf {     // and thus so is the method.
        self.async_nap().await
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Rust is a single language that's made up of several different sub-languages.
There are the macro languages, as well as the generics language, patterns,
const, unsafe, and async sub-languages. Rust works anywhere from a
micro-controller to Windows, and even browsers. One of the biggest challenges we
have is to not only keep the language as easy to use as we can, it's to ensure
it works relatively consistently on all the different platforms we support.</p>
<p>We're currently in the process of adding support for the <code>const</code> and <code>async</code>
language features to Rust. But we're looking at various other extensions as
well, such as generator functions, fallible functions, linearity, and more.
These are really big extensions to the language, whose implementation will take
on the order of years. If we want to successfully introduce these features,
they'll need to be integrated with every other part of the language. As well as
having wide support in the stdlib.</p>
<p>Effect Generic Trait Declarations are a minimal language feature which enable
traits to add support for new effects, without needing to duplicate the trait
itself. So rather than having a trait <code>Into</code>, <code>TryInto</code>, <code>AsyncInto</code>, and the
inevitable <code>TryAsyncInto</code> - we would declare a single trait <code>Into</code> once, which
has support for any combination of <code>async</code> and <code>try</code> effects. This is
backwards-compatible by design, and should be able to support any number of
effect extensions we come up with in the future. Ensuring the language can keep
evolving to our needs.</p>
<h2 id="guaranteeing-api-consistency"><a class="header" href="#guaranteeing-api-consistency">Guaranteeing API consistency</a></h2>
<p>Evolving a programming language and stdlib is pretty difficult. We have to pay
close attention to details. And in Rust specifically: once we make a mistake
it's pretty hard to roll back. And we've made mistakes with effects in the past,
which we now have to work with <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>In Rust 1.34 we stabilized a new trait: <code>TryInto</code>. This was supposed to be
the fallible version of the <code>Into</code> trait, containing a new associated type
<code>Error</code>.  However since Rust 1.0 we've also had the
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait, which
<em>also</em> provides a fallible conversion, but has an associated type <code>Err</code>. This
means that when writing a fallible conversion trait, it's unclear whether the
associated type should be called <code>Err</code> or <code>Error</code>.</p>
</div>
<p>This might seem minor, but without automation these subtle
similar-but-not-quite-the-same kinds of differences stand out. The only way to
ensure that different APIs in different contexts work consistently is via
automation. And the best automation we have for this is the type system.</p>
<h1 id="guide-level-explanation"><a class="header" href="#guide-level-explanation">Guide-level explanation</a></h1>
<h2 id="trait-definitions"><a class="header" href="#trait-definitions">Trait definitions</a></h2>
<p>The base of Effect Generic Trait Declarations is the ability to declare traits
as being generic over effects. This RFC currently only considers the <code>async</code>
effect, but should be applicable to most other effects (modulo <code>unsafe</code> and
<code>const</code>, more on that later). The way a trait is defined is by adding a
<code>#[maybe(effect)]</code> notation.  This signals that a trait may be implemented as
carrying the effect.  For example, a version of the <code>Read</code> trait which may or
may not be <code>async</code> would be defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait Read {
    #[maybe(async)]
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="trait-implementations"><a class="header" href="#trait-implementations">Trait implementations</a></h2>
<p>Traits can be implemented as either async or non-async.  The trait-level
<code>#[maybe(async)]</code> can be thought of as a const-generic bool which determines the
value of the method-level <code>#[maybe(async)]</code> declarations.  So if a trait is
implemented as <code>async</code>, all methods tagged as <code>#[maybe(async)]</code> have to be async
too.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The base implementation
impl Read for Reader {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; {
        // ...
    }
}

/// The async implementation
impl async Read for AsyncReader {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt; {
        // ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="method-markers"><a class="header" href="#method-markers">Method markers</a></h2>
<p>This RFC only covers trait methods which carry an effect or not. It does not
cover types which may or may not have effects. The intent is to add this via a
future extension, so for the scope of this RFC we have to be able to declare
certain methods as not being generic over effects. This is the default behavior;
no extra annotations are needed for this.</p>
<p>Taking the <code>Read</code> trait example again; the <code>chain</code> method returns a type <code>Chain</code>
which implements <code>Iterator</code>. Accounting for the <code>chain</code> method, the declaration
of <code>Read</code> would be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait Read {
    ...

    // This method is not available for `impl async Read`
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
       where Self: Sized { .. }
}
<span class="boring">}
</span></code></pre></pre>
<p>Because <code>chain</code> is not marked as <code>maybe(async)</code>, when implementing <code>async Read</code>,
it will not be available. If a synchronous method has to be available in an
async context, it should be possible to mark it as <code>not(async)</code>, so that it's
clear it's part of the API contract for the async implementation - and is never
async.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait Read {
    ...

    // This method would be available for `impl async Read`
    #[not(async)]
    fn chain&lt;R: Read&gt;(self, next: R) -&gt; Chain&lt;Self, R&gt;
       where Self: Sized { .. }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="reference-level-explanation"><a class="header" href="#reference-level-explanation">Reference-level explanation</a></h1>
<h2 id="effect-lowering"><a class="header" href="#effect-lowering">Effect lowering</a></h2>
<p>At the MIR level the lowering of <code>#[maybe(effect)]</code> is shared with <code>const</code>, and
is essentially implemented via const generic bools. Take the following maybe-async
definition of <code>Into</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Trait definition
#[maybe(async)]
trait Into&lt;T&gt;: Sized {
    #[maybe(async)]
    fn into(self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>At the type level the <code>#[maybe(async)]</code> system is lowered to a const bool which
determines whether the function should be async. If the trait is implemented as
async, the bool is set to true. If it isn't, it's set to false.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lowered trait definition
trait Into&lt;T, const IS_ASYNC: bool = false&gt;: Sized {
    type Ret = T;
    fn into(self) -&gt; Self::Ret;
}
<span class="boring">}
</span></code></pre></pre>
<p>By default the const bool is set to false. The return type of the
function here is the base return type of the definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The base implementation
impl Into&lt;Loaf&gt; for Cat {
    fn into(self) -&gt; Loaf {
        self.nap()
    }
}

// Lowered base trait impl
impl Into&lt;Loaf, false&gt; for Cat { // IS_ASYNC = false
    type Ret = T;
    fn into(self) -&gt; Self::Ret {
        self.nap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However if we implement the async version of the trait things change a little.
In the lowering the const bool is set to <code>true</code> to indicate we are in fact
async. And in the lowering we wrap the return type in an <code>impl Future</code>, as well
as return an anonymous <code>async {}</code> block from the function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The async implementation
impl async Into&lt;AsyncLoaf&gt; for AsyncCat {
    async fn into(self) -&gt; AsyncLoaf {
        self.async_nap().await
    }
}

// Lowered async trait impl
impl Into&lt;AsyncLoaf, true&gt; for AsyncCat { // IS_ASYNC = true
    type Ret = impl Future&lt;Output = T&gt;;
    fn into(self) -&gt; Self::Ret {
        async move {
            self.async_nap().await
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="effect-lowering-with-lifetimes"><a class="header" href="#effect-lowering-with-lifetimes">Effect lowering with lifetimes</a></h2>
<p>Things become more interesting when lifetimes are involved in the effectful
lowering of a trait. The return type of an <code>async fn</code> which takes a reference
has to be a future with a lifetime. Which means it's in our lowering our
associated type can't be a plain future - it has to be a future with a lifetime
attached. And this requires lifetime GATs to work.</p>
<p>Say instead of the async version of <code>Into</code>, we tried to write the maybe-async
version of <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a>
<sup class="footnote-reference"><a href="#asref">2</a></sup>. We could define it as follows:</p>
<div class="footnote-definition" id="asref"><sup class="footnote-definition-label">2</sup>
<p>this is just for the purpose of an example; I don't actually know of
any cases which want an async version of <code>AsRef</code>. But never say never.</p>
</div>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The trait definition
#[maybe(async)]
pub trait AsRef&lt;T&gt;
where
    T: ?Sized,
{
    #[maybe(async)]
    fn as_ref(&amp;self) -&gt; &amp;T;
}

/// The lowering of the trait definition
pub trait AsRef&lt;T, const IS_ASYNC: bool = false&gt;
where
    T: ?Sized,
{
    type Ret&lt;'a&gt; = &amp;'a T
        where Self: 'a;
    fn as_ref(&amp;self) -&gt; Self::Ret&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>We could then implement it like we did with our <code>Into</code> impl. The non-async impl
would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The base implementation
impl AsRef&lt;Loaf&gt; for Cat {
    fn as_ref(&amp;self) -&gt; &amp;Loaf {
        self.nap_ref()
    }
}

/// Lowering of the base implementation
impl AsRef&lt;Loaf, false&gt; for Cat { // IS_ASYNC = false
    type Ret&lt;'a&gt; = &amp;'a Loaf
        where Self: 'a;
    fn as_ref(&amp;self) -&gt; Self::Ret&lt;'_&gt; {
        self.nap_ref()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And the async implementation would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The base implementation
impl async AsRef&lt;Loaf&gt; for AsyncCat {
    async fn as_ref(&amp;self) -&gt; &amp;Loaf {
        self.async_nap_ref().await
    }
}

/// Lowering of the base implementation
impl AsRef&lt;AsyncLoaf, true&gt; for AsyncCat { // IS_ASYNC = true
    type Ret&lt;'a&gt; = impl Future&lt;Output = &amp;'a Loaf&gt; + 'a
        where Self: 'a;
    fn as_ref(&amp;self) -&gt; Self::Ret&lt;'_&gt; {
        async {
            self.async_nap_ref().await
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>While effect-generic trait definitions with lifetimes do rely on GATs in their
lowering, crucially they don't rely on any potential notion of lifetime-generics to
function. The right lifetime GATs can be emitted by the compiler during
lowering, and should therefor always be accurate.</p>
<h2 id="effect-states"><a class="header" href="#effect-states">Effect states</a></h2>
<p>This RFC reasons about effects as being in one of four logical states:</p>
<ul>
<li><strong>Always:</strong> This is when an effect is always present. For example: if a
function implements some kind of concurrency operations, it may always want to
be async. This is signaled by the existing meaning of the <code>async fn</code> notation.</li>
<li><strong>Maybe</strong>: This is when an effect may sometimes be present. This will
apply to most traits in the stdlib. For example, if we want to write an async
version of the <code>Read</code> trait its associated methods will also want to be <code>async</code>.</li>
<li><strong>Not</strong>: This is when an effect is never present. For example:
<code>Iterator::size_hint</code> will likely <em>never</em> want to be async, even if the trait
and most methods are async. In order for methods to be available in the
effectful implementatin of the trait, they have to be marked as never
carrying the effect.</li>
<li><strong>Unknown:</strong> Methods which haven't explicitly declared which logical state
they're in are <em>unknown</em>. This is a distinct state from <em>not</em>, because a method
may be converted from <em>unknown</em> to <em>maybe</em> without breaking backwards
compatibility.</li>
</ul>
<p>For the <code>async</code> effect methods which are always async are labeled <code>async fn</code>.
Methods which may or may not be async are labeled <code>#[maybe(async)]</code>. Methods
which are never async are labeled <code>#[not(async)]</code>. All other methods are
unlabeled, and are not made available to the async implementation of the trait.</p>
<h2 id="concrete-impls-and-coherence"><a class="header" href="#concrete-impls-and-coherence">Concrete impls and coherence</a></h2>
<p>With the eye on forward-compatibility, and a potential future where types can
themselves also be generic over effects, for now types may only implement either
the effectful or the base variant of the trait. This ensures that the door is
kept open for effect generic implementations later on. As well as ensures that
during trait selection the trait variant remains unambiguous. The diagnostics
for this case should clearly communicate that only a single trait variant can be
implemented per type.</p>
<pre><code class="language-text">error[E0119]: conflicting implementations of trait `Into` for type `Cat`
 --&gt; src/lib.rs:5:1
  |
4 | impl Into for Cat {}
  | ----------------- first implementation here
5 | impl async Into for Cat {}
  | ^^^^^^^^^^^^^^^^^ conflicting implementation for `Cat`
  |
  | help: types can't both implement the sync and async variant of a trait
</code></pre>
<h2 id="trait-bounds"><a class="header" href="#trait-bounds">Trait bounds</a></h2>
<p>Using effect generic trait definitions in trait bounds should be no problem,
assuming the bounds are concrete. Unlike concrete types, generic bounds may
implement both effecful and uneffectful implementations for the same bounds as
long as they target non-overlapping sets of traits. For example, assuming we had
a maybe-async version of <code>Into</code>, introducing a maybe-async version of <code>From</code>
would allow us to write the following non-overlapping generic bounds.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// If we also introduce a maybe-async
/// version of the `From` trait‚Ä¶
#[maybe(async)]
pub trait From&lt;T&gt;: Sized {
    #[maybe(async)]
    fn from(value: T) -&gt; Self;
}

/// ‚Ä¶we can implement the synchronous
/// variant for any type `T, U: From&lt;T&gt;`‚Ä¶
impl&lt;T, U&gt; Into&lt;U&gt; for T
where
    U: From&lt;T&gt; {}

/// ‚Ä¶as well as the asynchronous variant for
/// any type `T, U: async From&lt;T&gt;`.
impl&lt;T, U&gt; async Into&lt;U&gt; for T
where
    U: async From&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>For the purpose of the trait resolver, <code>From</code> and <code>async From</code> should be
considered non-overlapping bounds. This is a new capability which we'll need to
introduce, and effectively comes down to treating <code>U: From&lt;T, false&gt;</code> and <code>U: From&lt;T, true&gt;</code> as non-overlapping bounds. Effect-generic trait bounds
(conditional effects in bounds) are not introduced by this RFC, but may be introduced
by a future extension.</p>
<h2 id="super-traits"><a class="header" href="#super-traits">Super traits</a></h2>
<p>Super-trait hierarchies should be supported, as long as they are appropriately
annotated. Say we wanted to define a maybe-async version of
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html"><code>BufRead</code></a> which has
<code>Read</code> as a supertrait. For that to work, the <code>Read</code> trait would also need to be
marked maybe-async. That way if we implement the async version of <code>BufRead</code> we
also require the async version of <code>Read</code> - idem for the non-async variants.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait BufRead: #[maybe(async)] Read {
    #[maybe(async)]
    fn fill_buf(&amp;mut self) -&gt; Result&lt;&amp;[u8]&gt;;
    #[maybe(async)]
    fn consume(&amp;mut self, amt: usize);
}
<span class="boring">}
</span></code></pre></pre>
<p>If a trait wants to have a non-async super-trait, it has to mark the super-trait
as not being async. In the case that the supertrait eventually becomes generic
over an effect, it's clear from the beginning which variant we 've chosen. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait SuperTrait {}

#[maybe(async)]
pub trait SubTrait: #[not(async)] SuperTrait { }
<span class="boring">}
</span></code></pre></pre>
<p>Certain traits may want to guarantee ahead of time that they will never support
a certain effect. For these traits it is possible to omit the effect marker, as
the state of the effect is already unambiguous. It is expected most marker
traits will want to be unambiguously never support for example the <code>async</code>
effect.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The trait `Sized` guarantees it
// will not ever be an `async trait`‚Ä¶ 
#[not(async)]
trait Sized {}

// ‚Ä¶which means it does not require annotations
// when used as a supertrait.
#[maybe(async)]
trait Into&lt;T&gt;: Sized { .. }
<span class="boring">}
</span></code></pre></pre>
<h2 id="todo-prerequisites"><a class="header" href="#todo-prerequisites">TODO: prerequisites</a></h2>
<ul>
<li>associated type defaults</li>
<li>complex where bounds on associated items removing the need for them to get implemented</li>
<li>a working demo of the constness effect</li>
<li>T-types buy-in (not before the old solver got removed)</li>
</ul>
<h1 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h1>
<h2 id="const-effect-states"><a class="header" href="#const-effect-states">Const effect states</a></h2>
<p>The <code>const</code> keyword in Rust has two meanings: </p>
<ul>
<li><code>const {}</code> blocks are always const-evaluated (&quot;always&quot; semantics)</li>
<li><code>const fn</code> functions may be const evaluated (&quot;maybe&quot; semantics)</li>
</ul>
<p>Notably <code>const</code> does not provide a way to declare functions which must always
const-evaluated. This RFC determines all traits and methods can be in one of
four [states][#effect-states], including &quot;always async&quot; and &quot;maybe async&quot;. As a
result declaring a function which is &quot;maybe-async&quot; will syntactically appear
different from a function which is &quot;maybe-const&quot;.</p>
<h2 id="todo-additional-syntax"><a class="header" href="#todo-additional-syntax">TODO: Additional syntax</a></h2>
<ul>
<li>we're adding some new syntax, that's going to be A Thing</li>
</ul>
<h2 id="todo-direction"><a class="header" href="#todo-direction">TODO: Direction</a></h2>
<ul>
<li>while not inherently closing any doors, we are kind of committing to the idea
that we want to extend the stdlib to be effectful - that's the point</li>
<li>this has repercussions for how we structure our base traits and interfaces too</li>
</ul>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h1>
<p>TODO:</p>
<ul>
<li>swift: async polymorphism + rethrow</li>
<li>c++: noexcept + constexpr</li>
<li>koka: effect handlers (free monad)</li>
<li>rust: const fn</li>
<li>zig: maybe async functions</li>
</ul>
<h1 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved questions</a></h1>
<ul>
<li>may want to use an associated const instead of a const generic</li>
</ul>
<h2 id="todo-syntax"><a class="header" href="#todo-syntax">TODO: Syntax</a></h2>
<ul>
<li><code>#[maybe(async)]</code> is a placeholder</li>
<li><code>maybe(async)</code> is clear but is verbose</li>
<li><code>?async</code> is sigil-heavy, but has precedence in the trait system</li>
<li><code>~async</code> is sigil-heavy, and also reserves a new sigil</li>
<li><code>if/else</code> at the trait level does not create bidirectional relationships</li>
<li><code>async&lt;A&gt;</code> is less clear and verbose</li>
</ul>
<h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="todo-do-nothing-null-hypothesis"><a class="header" href="#todo-do-nothing-null-hypothesis">TODO: Do nothing (null hypothesis)</a></h2>
<ul>
<li>effect differences are inherent, which means they have to be solved somewhere</li>
<li>effect composition is where it gets bad; we have an async version of the stdlib, not an async + fallible version</li>
<li>things like linearity seem quite far out of reach right without this</li>
</ul>
<h1 id="future-possibilities"><a class="header" href="#future-possibilities">Future possibilities</a></h1>
<h2 id="todo-integration-with-other-keywords"><a class="header" href="#todo-integration-with-other-keywords">TODO: Integration with other keywords</a></h2>
<ul>
<li>fallible functions</li>
<li>generator functions</li>
<li>linearity</li>
</ul>
<h2 id="todo-effect-generic-types-and-bodies"><a class="header" href="#todo-effect-generic-types-and-bodies">TODO: Effect-generic types and bodies</a></h2>
<ul>
<li>types</li>
<li>functions</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Before: the base implementation
impl Into&lt;Loaf&gt; for Cat {
    fn into(self) -&gt; Loaf {
        self.nap()
    }
}

/// Before: the async implementation
impl async Into&lt;AsyncLoaf&gt; for AsyncCat {
    async fn into(self) -&gt; AsyncLoaf {
        self.async_nap().await
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// After: a single implementation
...
<span class="boring">}
</span></code></pre></pre>
<h2 id="todo-effect-sets"><a class="header" href="#todo-effect-sets">TODO: Effect sets</a></h2>
<ul>
<li>named effect sets</li>
<li>unify <code>core</code> and <code>std</code> via sets</li>
</ul>
<h2 id="todo-normalize-const"><a class="header" href="#todo-normalize-const">TODO: Normalize const</a></h2>
<ul>
<li><code>const fn</code> is maybe-const</li>
<li><code>const {}</code> is always const</li>
<li>this is super annoying lol, and that's why this system doesn't work for <code>const</code> right now</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>Feature Name: <code>effect-generic-bounds-and-functions</code></li>
<li>Start Date: (2024-01-20)</li>
<li>RFC PR: <a href="https://github.com/rust-lang/rfcs/pull/0000">rust-lang/rfcs#0000</a></li>
<li>Rust Issue: <a href="https://github.com/rust-lang/rust/issues/0000">rust-lang/rust#0000</a></li>
</ul>
<h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p><a href="explainer/./effect-generic-trait-declarations.html">RFC 0000</a> introduces traits which are
generic over an effect, but implementers have to pick whether they want to
implement the base version or the effectful version of the trait. This RFC
extends that system further by removing that limitation, and enabling authors to
write functions which themselves are generic over effects. For example, here is
a function <code>io::copy</code> which would be able to operate either synchronously or
asynchronously, depending on which types are passed to it.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This defines a trait `Read` which may or may not
/// be async, using the design introduced in RFC 0000.
#[maybe(async)]
pub trait Read {
    #[maybe(async)]
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;
}

/// This defines a trait `Write` which may or may not
/// be async, using the design introduced in RFC 0000.
#[maybe(async)]
pub trait Write {
    #[maybe(async)]
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    #[maybe(async)]
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
}

/// This defines a function `copy` which copies bytes from a
/// reader into a writer. This RFC enables this function to
/// operate either synchronously or asynchronously. Where if
/// operating synchronously, the `.await` operator becomes a
/// no-op.
#[maybe(async)] 
pub fn copy&lt;R, W&gt;(reader: &amp;mut R, writer: &amp;mut W) -&gt; Result&lt;()&gt;
where
    R: #[maybe(async)] Read + ?Sized,
    W: #[maybe(async)] Write + ?Sized,
{
    let mut buf = vec![0; 1024];
    loop {
        match reader.read(&amp;mut buf).await? {
            0 =&gt; return Ok(()),
            n =&gt; writer.write(&amp;mut buf[0..n]).await?,
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h1>
<p><a href="explainer/./effect-generic-trait-declarations.html">RFC 0000</a> introduced effect-generic
trait definitions: traits which are generic over effects, but implementors of
the trait have to pick which version they implement. This works fine when
authors know which effects they will be working with, like in applications. But
library authors will often want to write code which not only works with one
effect, but any number of effects. And for that effect-generic functions and
bounds would greatly help reduce the amount of code duplication.</p>
<p>The blog post: <a href="https://nullderef.com/blog/rust-async-sync/">&quot;The bane of my
existence: Supporting both async and sync code in
Rust&quot;</a> documents the negative
experience of one of the <a href="https://docs.rs/rspotify/latest/rspotify/index.html"><code>rspotify</code></a> authors maintaining both sync and async
versions of a crate. With ecosystem crates such as
<a href="https://docs.rs/maybe-async/latest/maybe_async/"><code>maybe_async</code></a> and
<a href="https://crates.io/crates/async-generic"><code>async-generic</code></a> attempting to provide
mitigations via the macro system. But these crates are limited in what they can
provide when it comes to integrating with Rust's libraries, diagnostics,
tooling, and inference systems.</p>
<p><code>rspotify</code> is a thoroughly documented example of an author wanting to be
generic over an effect, but there are others. Specifically for the async effect,
the <code>mongodb</code> crate has both <a href="https://docs.rs/mongodb/latest/mongodb/sync/index.html">sync</a> and <a href="https://docs.rs/mongodb/latest/mongodb/index.html">async</a> variants. So does the
<code>postgres</code> crate [<a href="https://docs.rs/postgres/latest/postgres/">sync</a>, <a href="https://docs.rs/tokio-postgres/latest/tokio_postgres/index.html">async</a>], as well as the <code>reqwest</code> crate
[<a href="https://docs.rs/reqwest/latest/reqwest/blocking/index.html">sync</a>, <a href="https://docs.rs/reqwest/latest/reqwest/">async</a>], and both the <a href="https://docs.rs/tokio"><code>tokio</code></a> and <a href="https://docs.rs/async-std"><code>async-std</code></a> crates
duplicate large swaths of the stdlib's functionality. Other effects are also
covered, such as <a href="https://docs.rs/fallible-iterator/latest/fallible_iterator/index.html"><code>fallible-iterator</code></a> for a version of the stdlib's <code>Iterator</code>
trait which short-circuits on error.  And <a href="https://crates.io/crates/fallible_vec"><code>fallible_vec</code></a> for a <code>Vec</code> type with
methods which may returns errors rather than panics if an allocation fails.</p>
<h1 id="guide-level-explanation-1"><a class="header" href="#guide-level-explanation-1">Guide-level explanation</a></h1>
<h2 id="effect-generic-functions"><a class="header" href="#effect-generic-functions">Effect-generic functions</a></h2>
<p>Effects such as <code>async</code>, <code>try</code>, or <code>gen</code> define a superset of the language. With
some minor exceptions, they provide access to more features than
functions which don't have the effect. However, to ensure the effect forwards
correctly through function bodies, we require some degree of annotations. In the
case of the <code>async</code> effect, we require function calls to be suffixed with
<code>.await</code>. In the case of <code>try</code>, we require function calls to be suffixed with
<code>?</code>. This is called &quot;effect forwarding&quot;.</p>
<p>Say we wanted to write a function <code>sum</code> which takes an <code>impl Iterator&lt;Item = u32&gt;</code> and sums all numbers together. If we included the trait definition, we could write it like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The `Iterator` trait
pub trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

/// Iterate over all numbers in the
/// iterator and sum them together
pub fn sum&lt;I: Iterator&lt;Item = u32&gt;&gt;(iter: I) -&gt; u32 {
    let mut total = 0;
    while let Some(n) = iter.next() {
        total += n;
    }
    total
}
<span class="boring">}
</span></code></pre></pre>
<p>This works fine for non-async code. In fact: this is almost exactly how the
stdlib versions of
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>Iterator::sum</code></a>
is defined. But this code has a limitation: the underlying iterator will always
block between calls to <code>next</code>. To resolve that, <code>next</code> should add support for
<code>async/.await</code>, which we can do by adding the <code>#[maybe(async)]</code> notation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The `Iterator` trait with optional
/// support for the `async` effect
#[maybe(async)]
pub trait Iterator {
    type Item;
    #[maybe(async)]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Nothing too exciting is going on yet. This is all uses the mechanisms we defined
in <a href="explainer/">RFC 0000</a>, and adding support for <code>async/.await</code> just required some extra
<code>#[maybe(async)]</code> annotations. This becomes more interesting once we start
looking to not only allow traits to be generic over the <code>async</code> effect, but
<em>functions</em> and <em>trait bounds</em> as well. The way we can do that is fairly
mechanical: all we have to do is add some extra <code>#[maybe(async)]</code> notations to
the function signature, and some extra <code>.await</code>s inside the function body.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Iterate over all numbers in the
/// iterator and sum them together
#[maybe(async)]                                // 1. async
pub fn sum&lt;I&gt;(iter: I) -&gt; u32
where
    I: #[maybe(async)] Iterator&lt;Item = u32&gt;    // 2. async
{
    let mut total = 0;
    while let Some(n) = iter.next().await {    // 3. .await
        total += n;
    }
    total
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example we've added additional <code>#[maybe(async)]</code> notations at comments
1, and 2. And in the function body added additional <code>.await</code> points at comment 3.
What's key here is that if we remove the <code>async</code> and <code>await</code> notations, we
end up back with a perfectly valid non-async code. And that's basically the way
the system works under the hood: when compiled as async, the <code>.await</code> points
signal suspension points. While when the function is compiled as non-async, you
can think of the <code>.await</code> points as immediately returning if they suspend.</p>
<p>In order to make this system work though, we have to apply some rules. The
first rule is that <code>#[maybe(async)]</code> functions can't directly call <code>async</code>
functions. Remember: our function needs to be able to strip away the <code>.await</code>
points and still compile. If a function is always async, then removing the
<code>.await</code> points would leave us with an invalid function, so that's not allowed.</p>
<p>The second rules is: maybe-async functions may or may not return futures. So we
can't treat the return type like a concrete future which we can freely pass
around. That means that in <code>#[maybe(async)]</code> contexts, the only valid thing to
do with futures is to <code>.await</code> immediately them.</p>
<h2 id="using-effect-specific-behavior"><a class="header" href="#using-effect-specific-behavior">Using effect-specific behavior</a></h2>
<p>Not being able to treat futures as first-class items in <code>#[maybe(async)]</code>
functions might seem like a pretty big restriction: half the reason to use
<code>async/.await</code> in the first place is to be able to concurrently execute
computations. But there is a direct way out for us here: intrinsic-based
specialization.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn runtime() -&gt; i32 { 1 }
const fn compiletime() -&gt; i32 { 1 }
unsafe { const_eval_select((), compiletime, runtime) }
<span class="boring">}
</span></code></pre></pre>
<p>const functions can specialize their behavior using the <code>const_eval_select</code>
intrinsic. Depending on whether execution is occurring during compilation or at
runtime, different code will be run. For <code>async</code> and other effects, we'll be
providing a similar intrinsic. Depending on whether a function is compiled as
async or not, different code will be run.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn not_async() { println!(&quot;hello sync&quot;); }
async fn yes_async() { println!(&quot;hello async&quot;); }
unsafe { async_eval_select((), not_async, yes_async) }
<span class="boring">}
</span></code></pre></pre>
<p>Within the <code>async</code> function it would be possible to freely operate on futures as
first-class items: freely applying concepts such as concurrency, cancellation,
and combinations of the two. In the future we may choose to expose similar
functionality via a first-class language feature instead. See the future
possibilities section for a discussion of this.</p>
<h2 id="effect-selection-and-inference"><a class="header" href="#effect-selection-and-inference">Effect selection and inference</a></h2>
<p>While functions can be written as generic over effects, when they're finally
compiled the compiler needs to know which variant to use. In most cases the
compiler should be able to infer this unambiguously from the context. When a
<code>#[maybe(async)]</code> function is called from an <code>async</code> context, and the is then
<code>.await</code>ed - the compiler can be pretty certain we're interested in the <code>async</code>
version of the function.</p>
<pre><pre class="playground"><code class="language-rust">#[maybe(async)]
fn meow() {
    println!(&quot;meow&quot;);
}

async fn main() {
    meow().await; // `fn meow` can be inferred to be `async`
}
</code></pre></pre>
<p>If the presence - or absence - of <code>.await</code> calls isn't enough to inform the
compiler, it will look at whether the enclosing context is <code>async</code> or not. And
if that's not enough to unambiguously figure out which variant to select, it
will always be possible to explicitly tell the compiler which variant we
expected using turbofish notation.</p>
<pre><pre class="playground"><code class="language-rust">#[maybe(async)]
fn meow() {
    println!(&quot;meow&quot;);
}

async fn main() {
    let fut = meow::&lt;async&gt;();   // `fn meow` is async
    meow::&lt;#[not(async)]&gt;();     // `fn meow` is not async
}
</code></pre></pre>
<h2 id="effect-generic-provided-trait-methods"><a class="header" href="#effect-generic-provided-trait-methods">Effect generic provided trait methods</a></h2>
<p>This RFC not just enables free functions to be generic over effects: it also
enables provided trait methods to work with effect generics. Take for example
our maybe-async trait <code>Read</code> again. By default it provides a number of methods,
including <code>read_to_end</code>. With effect generic trait definitions, those provided
functions can be generic over effects, meaning they can be made available to the
effectful and base variants of the trait alike.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub trait Read {
    // Using RFC 0000 required trait methods gained
    // support for `#[maybe(effect)]` annotations.
    #[maybe(async)]
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    // With this RFC, entire functions can be made
    // generic over effects, meaning provided functions
    // in traits now also work with `#[maybe(effect)]`.
    #[maybe(async)]
    fn read_to_end(&amp;mut self, buf: &amp;mut Vec&lt;u8&gt;) -&gt; Result&lt;usize&gt; { .. }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="reference-level-explanation-1"><a class="header" href="#reference-level-explanation-1">Reference-level explanation</a></h1>
<h2 id="todo-lowering"><a class="header" href="#todo-lowering">TODO: Lowering</a></h2>
<p><em>NOTE: this section is incomplete and in-progress. While we know it is possible
because we have implemented a working version of this outside of the compiler,
there are changes in the compiler happening which means this section may change.
Once those changes have landed, this section should be rewritten to match that.
Until that time please consider this section incomplete and subject to change.</em></p>
<p>Let's continue with our earlier example of the trait <code>Iterator</code> and the function
<code>sum</code> which both have conditional support for the <code>async</code> effect via
<code>#[maybe(async)]</code>. In its base form the trait <code>Iterator</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The `Iterator` trait
#[maybe(async)]
pub trait Iterator {
    type Item;
    #[maybe(async)]
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Which using the desugaring proposed in RFC 0000, would desugar to a trait with a
const-generic bool which determines whether it is async or not:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lowered trait definition
pub trait Iterator&lt;const IS_ASYNC: bool = false&gt; {
    type Item;
    type Ret = Option&lt;Self::Item&gt;;
    fn next(&amp;mut self) -&gt; Ret;
}
<span class="boring">}
</span></code></pre></pre>
<p>We've seen how when maybe-async traits are implemented as sync they return their
base type, and when implemented as async they wrap that up in an <code>impl Future</code> -
see RFC 0000's section on &quot;Lowering&quot; for more details. Now for our function
body, the base definition looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[maybe(async)]
pub fn sum&lt;I&gt;(iter: I) -&gt; u32
where
    I: #[maybe(async)] Iterator&lt;Item = u32&gt;
{
    let mut total = 0;
    while let Some(n) = iter.next().await {
        total += n;
    }
    total
}
<span class="boring">}
</span></code></pre></pre>
<p>TODO: ask oli for more details about the desugaring. Ref is: https://github.com/yoshuawuyts/maybe-async-channel/blob/2fc6fa012830525482d62a8facfae5e5a5e762fe/maybe-async-std/src/lib.rs#L47-L54</p>
<h2 id="carried-effects-as-non-destructive-code-transformations"><a class="header" href="#carried-effects-as-non-destructive-code-transformations">Carried effects as non-destructive code transformations</a></h2>
<p>The reason why this RFC is able to write function bodies which are generic over
effects is because effects such as <code>async</code> are non-destructive. Adding the
<code>async</code> notation to a function does not lose any information - meaning you can
arrive at the function signature and body you might had had before simply by
removing the <code>async</code> and <code>.await</code> notation.</p>
<p>Take this simple async function. It calls the method <code>meow</code> on some type
<code>cat</code>, returning <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 1. Our base `meow` function
fn meow() -&gt; String {
    cat.meow()
}
<span class="boring">}
</span></code></pre></pre>
<p>Say <code>cat.meow</code> was <code>async</code> instead. We could change our function to support it
simply by adding the necessary <code>async</code> and <code>.await</code> notations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 2. The async version of `meow`
async fn meow() -&gt; String {
    cat.meow().await
}
<span class="boring">}
</span></code></pre></pre>
<p>Because adding <code>async</code> and <code>.await</code> does not erase any information from the base
function, it is non-destructive. Meaning we can always reverse it by removing
all the calls to <code>async</code> and <code>.await</code>, arriving back at the function we
initially had.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 3. Stripping the `async/.await` notations
/// yields our base function again
fn meow() -&gt; String {
    cat.meow()
}
<span class="boring">}
</span></code></pre></pre>
<p>Uncarried effects such as <code>const</code> don't require any forwarding notations, and so
are by definition non-destructive in their transformation. In addition to
<code>async</code>, Rust has two other carried effects: <code>gen</code> and <code>try</code>. Parts of both of
these effects are unstable or undecided, but there is no reason we should
require their notation to be destructive. Given the unstable nature of these
effects, we'll cover them in more detail in the &quot;future possibilities&quot; section
of this RFC.</p>
<table><thead><tr><th>effect name</th><th>forwarding notation</th><th>desugaring</th><th>logical return type</th><th>carried type</th></tr></thead><tbody>
<tr><td><code>async</code></td><td><code>.await</code></td><td><code>impl Future&lt;Output = T&gt;</code></td><td><code>T</code></td><td><code>!</code></td></tr>
<tr><td><code>try</code>‚Ä†</td><td><code>?</code></td><td><code>impl Try&lt;Output = T, Residual = R&gt;</code>‚Ä†</td><td><code>T</code></td><td><code>R</code></td></tr>
<tr><td><code>gen</code>‚Ä†</td><td><code>yield from</code> ‚Ä°</td><td><code>impl Iterator&lt;Item = U&gt;</code></td><td><code>()</code></td><td><code>U</code></td></tr>
</tbody></table>
<p><em>‚Ä† These items exist in Rust, but are unstable.</em></p>
<p><em>‚Ä° These items have been discussed for inclusion, but have not yet been included on nightly.</em></p>
<p><em>&quot;logical return type&quot; in this context means: the type the function returns
after the function has been evaluated and any forwarding notation has been
applied. The &quot;carried type&quot; here refers to the additional types end-users need
to be aware of when the effect is introduced. For example, when using the <code>try</code>
effect, users will be exposed to additional <code>Result&lt;_, E&gt;</code> or <code>Option</code> types.</em></p>
<h2 id="todo-unambiguous-variant-selection"><a class="header" href="#todo-unambiguous-variant-selection">TODO: Unambiguous variant selection</a></h2>
<ul>
<li><code>copy::&lt;async&gt;(read, writer).await?;</code></li>
</ul>
<h2 id="todo-effect-generic-bodies-logic"><a class="header" href="#todo-effect-generic-bodies-logic">TODO: Effect-generic bodies logic</a></h2>
<table><thead><tr><th align="right"></th><th>caller does not have effect</th><th>caller may have an effect</th><th>caller always has effect</th></tr></thead><tbody>
<tr><td align="right"><strong>callee does not have effect</strong></td><td>‚úÖ allowed to evaluate</td><td>‚úÖ allowed to evaluate</td><td>‚úÖ allowed to evaluate</td></tr>
<tr><td align="right"><strong>callee may have effect</strong></td><td>‚úÖ allowed to evaluate</td><td>‚úÖ allowed to evaluate</td><td>‚úÖ allowed to evaluate</td></tr>
<tr><td align="right"><strong>callee always has effect</strong></td><td>‚ùå not allowed to evaluate</td><td>‚ùå not allowed to evaluate</td><td>‚úÖ allowed to evaluate</td></tr>
</tbody></table>
<p>Evaluating an async function in a non-async context is not possible.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Caller context does not have an effect,
//! callee always has an effect

async fn callee() {}
fn caller() {
    callee().await // ‚ùå cannot call `.await` in non-async context
}
<span class="boring">}
</span></code></pre></pre>
<p>The caller's context may be evaluated as synchronous, but the callee is
guaranteed to always be asynchronous. Because as we've seen it's not possible to
evaluate async functions in non-async contexts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Caller context may have an effect,
//! callee always has an effect

async fn callee() {}
#[maybe(async)]
fn caller() {
    callee().await // ‚ùå cannot call `.await` in maybe-async context
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="todo-effect-row-polymorphism"><a class="header" href="#todo-effect-row-polymorphism">TODO: effect-row polymorphism</a></h2>
<ul>
<li>the effect for all members in a function is the same bound</li>
<li>if you mix async + non-async, both have to be async to work</li>
<li>but that's generally ok: there's a subtyping relationship possible, so even if
we don't do it automatically we can just do it ourselves</li>
</ul>
<h2 id="todo-prerequisites-1"><a class="header" href="#todo-prerequisites-1">TODO: Prerequisites</a></h2>
<ul>
<li>ask oli about which compiler features we're missing to implement this</li>
</ul>
<h1 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h1>
<h2 id="limits-the-future-effects-we-can-add"><a class="header" href="#limits-the-future-effects-we-can-add">Limits the future effects we can add</a></h2>
<ul>
<li>Being able to add N new carried effects for various different purposes is out of the cards</li>
<li>But we're specifically fine with the carried effects we have, uncarried
effects are more interesting as they provide more features by constraining the
design space</li>
<li>Arbitrary user-defined effects can likely be defined by contexts/capabilities + yield</li>
</ul>
<h1 id="rationale-and-alternatives"><a class="header" href="#rationale-and-alternatives">Rationale and alternatives</a></h1>
<h2 id="todo-dont-require-forwarding-notation"><a class="header" href="#todo-dont-require-forwarding-notation">TODO: Don't require forwarding notation</a></h2>
<ul>
<li>important though; as that's where control flow may happen</li>
<li>the possibility of something happening is the entire point of annotating it</li>
</ul>
<h2 id="todo-flattened-compositional-hierarchy"><a class="header" href="#todo-flattened-compositional-hierarchy">TODO: Flattened compositional hierarchy</a></h2>
<ul>
<li>requires a <code>do</code> notation / <code>.await?</code> / <code>?.await</code> become a single operation</li>
<li>ends up with a single <code>Coroutine</code> uber trait from which all other traits are derived</li>
<li>only covers carried effects, not uncarried ones</li>
<li>unclear how it would enable effect-generic functions to be authored</li>
<li>results in a system of trait aliases</li>
</ul>
<h2 id="todo-sans-io"><a class="header" href="#todo-sans-io">TODO: sans-io</a></h2>
<ul>
<li>yeah sans-io is cool</li>
<li>but it depends on passing things like <code>impl Read</code> rather than directly calling <code>File::open</code></li>
<li>this means taking maybe-async interfaces, and so we need maybe-async logic</li>
<li>ergo: while a good idea, it's not an alternative</li>
</ul>
<h2 id="todo-tls-preserving-closures"><a class="header" href="#todo-tls-preserving-closures">TODO: TLS-preserving closures</a></h2>
<ul>
<li>unclear how we would combine scope escapes with the borrow checker</li>
<li>threading through effects + forwarding notations through all call sites achieves the same effect</li>
<li>main challenge is backwards-compat, but effect generics address that</li>
</ul>
<h1 id="prior-art-1"><a class="header" href="#prior-art-1">Prior art</a></h1>
<h2 id="const-fn"><a class="header" href="#const-fn">const fn</a></h2>
<p>Using the <code>const</code> keyword this is already possible in Rust: a single <code>const fn</code>
function can both be evaluated during compilation and at runtime. Contrast this
to <code>const {}</code> blocks, which can only be evaluated at compile-time. And using the
<a href="https://doc.rust-lang.org/core/intrinsics/fn.const_eval_select.html"><code>const_eval_select</code></a>
intrinsic it will even be possible to provide different implementations
depending on whether the function is evaluated at runtime or during compilation.
This enables the runtime variant of a function to provide more optimized
implementations, for example by leveraging platform-specific SIMD capabilities.</p>
<h1 id="unresolved-questions-1"><a class="header" href="#unresolved-questions-1">Unresolved questions</a></h1>
<h1 id="future-possibilities-1"><a class="header" href="#future-possibilities-1">Future possibilities</a></h1>
<h2 id="todo-try-contexts"><a class="header" href="#todo-try-contexts">TODO: <code>try/?</code> contexts</a></h2>
<ul>
<li>is already non-destructive</li>
<li>just unstable right now</li>
</ul>
<h2 id="todo-genyield-from-contexts"><a class="header" href="#todo-genyield-from-contexts">TODO: <code>gen/yield from</code> contexts</a></h2>
<ul>
<li>Recognize that the return type is not the yield type</li>
<li>An additional <code>yield from</code>-alike syntax would be helpful here
<ul>
<li>preferred notation: <code>for yield..in expr;</code></li>
</ul>
</li>
</ul>
<h2 id="todo-composition-of-genyield-from-asyncawait-and-try"><a class="header" href="#todo-composition-of-genyield-from-asyncawait-and-try">TODO: Composition of <code>gen/yield from</code>, <code>async/.await</code> and <code>try/?</code></a></h2>
<ul>
<li>2/3 of these effects have unstable components</li>
<li>but they would compose Just Fine</li>
<li>this should be its own RFC though</li>
</ul>
<h2 id="todo-arbitrary-user-defined-carried-effects"><a class="header" href="#todo-arbitrary-user-defined-carried-effects">TODO: Arbitrary user-defined carried effects</a></h2>
<ul>
<li>composition of <code>yield</code>, contexts/capabilities, and concrete types</li>
<li>a handler can be expressed as a context or capability</li>
<li>we can yield N values to it by passing it a generator function</li>
<li>See also: &quot;capabilities: effects for free&quot; which applies this idea</li>
<li>Removes the need for arbitrary built-in control-flow effects</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effects-in-rust"><a class="header" href="#effects-in-rust">Effects in Rust</a></h1>
<p>Rust has a number of built-ins which sure look a lot like effects. In this
section we cover what those are, how they're in use today, touch on some of the
pain-points experienced by them.</p>
<h2 id="what-do-we-mean-by-effect-in-this-section"><a class="header" href="#what-do-we-mean-by-effect-in-this-section">What do we mean by &quot;effect&quot; in this section?</a></h2>
<p>For the purpose of this section we're considering effects in the broadest terms:
&quot;Any built-in language mechanism which triggers a bifurcation of the design
space&quot;. This means: anything which causes you to create a parallel, alternate
copy of the same things is considered an effect in this space.</p>
<p>This is probably not the definition we'll want to use in other sections, since
effects should probably only ever apply to functions. In this section we're
going to use &quot;effect&quot; as a catch-all term for &quot;things that sure seem effect-y&quot;.
When discussing effects we'll differentiate between:</p>
<ul>
<li><strong>Scoped Effects</strong>: which are effects which apply to functions and scopes, such
as <code>async fn</code> which are reified as traits or types such as <code>impl Iterator</code>.</li>
<li><strong>Data-Type Effects</strong>: which are Effects which apply to data types, encoded as
auto-traits. For example: the <code>Send</code> auto-trait is automatically implemented on structs
as long as its contained types are <code>Send</code>, and marks it as &quot;thread-safe&quot;.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchrony-scoped-effect"><a class="header" href="#asynchrony-scoped-effect">Asynchrony (Scoped Effect)</a></h1>
<h2 id="description-1"><a class="header" href="#description-1">Description</a></h2>
<p>Asynchrony in Rust enables non-blocking operations to be authored in an
imperative fashion. This can be helpful for performance reasons, but
feature-wise it enables &quot;arbitrary concurrency&quot; and &quot;arbitrary cancellation&quot; of
computations. These can in turn be composed and leveraged by higher-level
control-flow primitives such as &quot;arbitrary timeouts&quot; and &quot;arbitrary
parallel execution&quot;.</p>
<p>Asynchrony in Rust is implemented using a pair of keywords. <code>async</code> is used to
create an async context which is reified into a state machine backed by the
<code>Future</code> trait. And <code>.await</code> is used on the call-site to access the values
inside of an async context. Because <code>.await</code> can only be called inside of
<code>async</code> contexts, it eventually needs to be consumed by a top-level function
which knows how to run a future to completion.</p>
<h2 id="feature-status"><a class="header" href="#feature-status">Feature Status</a></h2>
<p><code>async/.await</code> in Rust is considered &quot;MVP stable&quot;. This means the reification of
the effect is stable, and both the <code>async</code> and <code>.await</code> keywords exist in the
language, but not all keyword positions are available yet.</p>
<h2 id="feature-categorization"><a class="header" href="#feature-categorization">Feature categorization</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td><code>async</code></td></tr>
<tr><td>Yield</td><td>N/A</td></tr>
<tr><td>Apply</td><td><code>.await</code></td></tr>
<tr><td>Consume</td><td><code>thread::block_on</code> ‚Ä†, <code>async fn main</code> ‚Ä°</td></tr>
<tr><td>Reification</td><td><code>impl Future</code></td></tr>
</tbody></table>
<blockquote>
<p>‚Ä† <code>thread::block_on</code> is not yet part of the stdlib, and only exists as a
library feature. An example implementation can be found in the
<a href="https://doc.rust-lang.org/std/task/trait.Wake.html#examples"><code>Wake</code></a> docs.</p>
</blockquote>
<blockquote>
<p>‚Ä° <code>async fn main</code> is not yet part of the language, and only exists as a
proc-macro extension as part of the ecosystem. It chiefly wraps the existing <code>fn main</code> logic in a <code>thread::block_on</code> call.</p>
</blockquote>
<h2 id="positions-available"><a class="header" href="#positions-available">Positions Available</a></h2>
<table><thead><tr><th>Position</th><th>Available</th><th>Example</th></tr></thead><tbody>
<tr><td>Manual trait impl</td><td>‚úÖ</td><td><code>impl Future for Cat {}</code></td></tr>
<tr><td>Free functions</td><td>‚úÖ</td><td><code>async fn meow() {}</code></td></tr>
<tr><td>Inherent functions</td><td>‚úÖ</td><td><code>impl Cat { async fn meow() {} } </code></td></tr>
<tr><td>Trait methods</td><td>‚è≥</td><td><code>trait Cat { async fn meow() {} }</code></td></tr>
<tr><td>Trait declarations</td><td>‚ùå</td><td><code>async trait Cat {}</code></td></tr>
<tr><td>Block scope</td><td>‚úÖ</td><td><code>fn meow() { async {} }</code></td></tr>
<tr><td>Argument qualifiers</td><td>‚ùå</td><td><code>fn meow(cat: impl async Cat) {}</code></td></tr>
<tr><td>Data types ‚Ä†</td><td>‚ùå</td><td><code>async struct Cat {}</code></td></tr>
<tr><td>Drop ‚Ä†</td><td>‚ùå</td><td><code>impl async Drop for Cat {}</code></td></tr>
<tr><td>Closures</td><td>‚ùå</td><td><code>async «Ä«Ä  {}</code></td></tr>
<tr><td>Iterators</td><td>‚ùå</td><td><code>for await cat in cats {}</code></td></tr>
</tbody></table>
<blockquote>
<p>‚Ä† In non-async Rust if you place a value which implements <code>Drop</code> inside of
another type, the destructor of that value is run when the enclosing type is
destructed. This is called <em>drop-forwarding</em>. In order for drop-forwarding to
work with async drop, some form of &quot;async value&quot; notation will be required.</p>
</blockquote>
<h2 id="refinements"><a class="header" href="#refinements">Refinements</a></h2>
<table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody>
<tr><td>cancellation-safe</td><td>Has no associated future-local state</td></tr>
</tbody></table>
<h3 id="cancellation-safe-futures"><a class="header" href="#cancellation-safe-futures">Cancellation-Safe Futures</a></h3>
<p>&quot;cancellation-safety&quot; is currently more like a term of art than an first-class
term. It is a property used and relied upon by ecosystem APIs, but it is not
represented in the type system anywhere. Which means APIs which rely on
&quot;cancellation-safety&quot; do so without compiler-backing, which makes them a
notorious source of bugs. This should probably be fixed, and when we do we
probably will not want to call it &quot;cancellation-safety&quot; since it relates less to
&quot;cancellation&quot; and more to the statefulness of futures, and whether or not they
can be recreated without side-effects or data loss.</p>
<h3 id="fused-futures"><a class="header" href="#fused-futures">Fused Futures</a></h3>
<p>A <code>FusedFuture</code> super-trait also exists, but it does not meaningfully feel like
a modifier of the &quot;async&quot; effect. It only adds an <code>is_terminated</code> method which
returns a bool. It does not inherently change the semantic functioning of the
underlying <code>Iterator</code> trait, or enhance it with behavior which is otherwise
absent. This is different from e.g. <code>FusedIterator</code> which says something about
the behavior of the <code>Iterator::next</code> function.</p>
<p>It's also worth noting that the <code>FusedFuture</code> trait is mostly useful for the
<code>select!</code> control-flow construct. Without that, <code>FusedFuture</code> would likely not
see much use
(<a href="https://blog.yoshuawuyts.com/futures-concurrency-3/#fuse-requirements">ref</a>).</p>
<h2 id="interactions-with-other-effects"><a class="header" href="#interactions-with-other-effects">Interactions with other effects</a></h2>
<h3 id="asynchrony"><a class="header" href="#asynchrony">Asynchrony</a></h3>
<h3 id="compile-time-execution"><a class="header" href="#compile-time-execution">Compile-time Execution</a></h3>
<h3 id="fallibility"><a class="header" href="#fallibility">Fallibility</a></h3>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<h3 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h3>
<h3 id="memory-safety"><a class="header" href="#memory-safety">Memory-Safety</a></h3>
<h3 id="immovability"><a class="header" href="#immovability">Immovability</a></h3>
<h3 id="object-safety"><a class="header" href="#object-safety">Object-Safety</a></h3>
<h3 id="ownership"><a class="header" href="#ownership">Ownership</a></h3>
<h3 id="thread-safety"><a class="header" href="#thread-safety">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compile-time-execution-scoped-effect"><a class="header" href="#compile-time-execution-scoped-effect">Compile-time Execution (Scoped Effect)</a></h1>
<h2 id="description-2"><a class="header" href="#description-2">Description</a></h2>
<p>The <code>const</code> keyword marks functions as &quot;is allowed to be evaluated during
compilation&quot;. When used in scope position its meaning changes slightly to: &quot;this
<em>will</em> be evaluated during compilation&quot;. There is no way to declare &quot;must be
evaluated at compilation&quot; functions, causing the meaning of &quot;const&quot; to be
context-dependent.</p>
<table><thead><tr><th></th><th>declaration</th><th>usage</th></tr></thead><tbody>
<tr><td><strong>keyword never applies</strong></td><td><code>fn meow() {}</code></td><td><code>fn hello() { meow() }</code></td></tr>
<tr><td><strong>keyword always applies</strong></td><td>-</td><td><code>const CAT: () = {};</code></td></tr>
<tr><td><strong>keyword conditionally applies</strong></td><td><code>const fn meow() {}</code></td><td><code>const fn hello() { meow() }</code></td></tr>
</tbody></table>
<h2 id="feature-status-1"><a class="header" href="#feature-status-1">Feature Status</a></h2>
<p>The <code>const</code> feature is integrated in a lot of the stdlib and ecosystem already,
but it's notoriously missing any form of const-traits. Because a lot of Rust's
language features make use of traits, this means const contexts have no access
to iteration, <code>Drop</code> handlers, closures, and more.</p>
<h2 id="feature-categorization-1"><a class="header" href="#feature-categorization-1">Feature categorization</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td><code>const fn</code></td></tr>
<tr><td>Yield</td><td>N/A</td></tr>
<tr><td>Apply</td><td>automatic</td></tr>
<tr><td>Consume</td><td><code>const {}</code>, <code>const X: Ty = {}</code></td></tr>
<tr><td>Reification</td><td>N/A</td></tr>
</tbody></table>
<h2 id="positions-available-1"><a class="header" href="#positions-available-1">Positions Available</a></h2>
<table><thead><tr><th>Position</th><th>Available</th><th>Example</th></tr></thead><tbody>
<tr><td>Manual trait impl</td><td>‚ùå</td><td>N/A</td></tr>
<tr><td>Free functions</td><td>‚úÖ</td><td><code>const fn meow() {}</code></td></tr>
<tr><td>Inherent functions</td><td>‚úÖ</td><td><code>impl Cat { const fn meow() {} } </code></td></tr>
<tr><td>Trait methods</td><td>‚è≥</td><td><code>trait Cat { const fn meow() {} }</code></td></tr>
<tr><td>Trait declarations</td><td>‚ùå</td><td><code>const trait Cat {}</code></td></tr>
<tr><td>Block scope</td><td>‚úÖ</td><td><code>fn meow() { const {} }</code></td></tr>
<tr><td>Argument qualifiers</td><td>‚ùå</td><td><code>fn meow(cat: impl const Cat) {}</code></td></tr>
<tr><td>Data types</td><td>‚ùå</td><td><code>const struct Cat {}</code></td></tr>
<tr><td>Drop</td><td>‚ùå</td><td><code>impl const Drop for Cat {}</code></td></tr>
<tr><td>Closures</td><td>‚ùå</td><td><code>const «Ä«Ä {}</code></td></tr>
<tr><td>Iterators</td><td>‚ùå</td><td><code>for cat in cats {}</code></td></tr>
</tbody></table>
<h2 id="refinements-1"><a class="header" href="#refinements-1">Refinements</a></h2>
<p>There are currently no refiments to the compile-time execution effect.</p>
<h2 id="interactions-with-other-effects-1"><a class="header" href="#interactions-with-other-effects-1">Interactions with other effects</a></h2>
<h3 id="asynchrony-1"><a class="header" href="#asynchrony-1">Asynchrony</a></h3>
<h3 id="compile-time-execution-1"><a class="header" href="#compile-time-execution-1">Compile-time Execution</a></h3>
<h3 id="fallibility-1"><a class="header" href="#fallibility-1">Fallibility</a></h3>
<h3 id="iteration-1"><a class="header" href="#iteration-1">Iteration</a></h3>
<h3 id="unwinding-1"><a class="header" href="#unwinding-1">Unwinding</a></h3>
<h3 id="memory-safety-1"><a class="header" href="#memory-safety-1">Memory-Safety</a></h3>
<h3 id="immovability-1"><a class="header" href="#immovability-1">Immovability</a></h3>
<h3 id="object-safety-1"><a class="header" href="#object-safety-1">Object-Safety</a></h3>
<h3 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h3>
<h3 id="thread-safety-1"><a class="header" href="#thread-safety-1">Thread-Safety</a></h3>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://blog.yoshuawuyts.com/const-syntax/">Keywords II: Const Syntax</a></li>
<li><a href="https://without.boats/blog/const-as-an-auto-trait/">Const as an auto-trait</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallibility-scoped-effect"><a class="header" href="#fallibility-scoped-effect">Fallibility (Scoped Effect)</a></h1>
<h2 id="feature-status-2"><a class="header" href="#feature-status-2">Feature Status</a></h2>
<p>todo</p>
<h2 id="description-3"><a class="header" href="#description-3">Description</a></h2>
<p>todo</p>
<h2 id="refinements-2"><a class="header" href="#refinements-2">Refinements</a></h2>
<table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Option&lt;T&gt;</code></td><td>Used to describe optional values</td></tr>
<tr><td><code>Result&lt;T, E&gt;</code></td><td>Used to describe errors or success values</td></tr>
<tr><td><code>ControlFlow&lt;B, C&gt;</code></td><td>Used to represent control-flow loops</td></tr>
<tr><td><code>Poll&lt;T&gt;</code></td><td>Used to describe the state of <code>Future</code> state machines</td></tr>
</tbody></table>
<p>While the reification of the fallibility effect in bounds ought to be <code>impl Try</code>, it more commonly is the case that we see concrete types used.</p>
<h2 id="feature-categorization-2"><a class="header" href="#feature-categorization-2">Feature categorization</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td><code>try</code></td></tr>
<tr><td>Yield</td><td><code>throw</code></td></tr>
<tr><td>Apply</td><td><code>?</code></td></tr>
<tr><td>Consume</td><td><code>match</code> / <code>fn main()</code> ‚Ä†</td></tr>
<tr><td>Reification</td><td><code>impl Try</code></td></tr>
</tbody></table>
<blockquote>
<p>‚Ä† <code>fn main</code> implements effect polymorphism over the fallibility effect
by making use of the <a href="https://doc.rust-lang.org/std/process/trait.Termination.html"><code>Termination</code> trait</a>. It stands to reason that <em>if</em> we
had a <code>try</code> notation for functions, that it should be possible to write
<code>try fn main</code> which desugars to a <code>Result</code> type being returned.</p>
</blockquote>
<h2 id="interactions-with-other-effects-2"><a class="header" href="#interactions-with-other-effects-2">Interactions with other effects</a></h2>
<h3 id="asynchrony-2"><a class="header" href="#asynchrony-2">Asynchrony</a></h3>
<h3 id="compile-time-execution-2"><a class="header" href="#compile-time-execution-2">Compile-time Execution</a></h3>
<h3 id="fallibility-2"><a class="header" href="#fallibility-2">Fallibility</a></h3>
<h3 id="iteration-2"><a class="header" href="#iteration-2">Iteration</a></h3>
<h3 id="may-panic"><a class="header" href="#may-panic">May Panic</a></h3>
<h3 id="memory-unsafety"><a class="header" href="#memory-unsafety">Memory-Unsafety</a></h3>
<h3 id="must-not-move"><a class="header" href="#must-not-move">Must-not Move</a></h3>
<h3 id="object-safety-2"><a class="header" href="#object-safety-2">Object-Safety</a></h3>
<h3 id="ownership-2"><a class="header" href="#ownership-2">Ownership</a></h3>
<h3 id="thread-safety-2"><a class="header" href="#thread-safety-2">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iteration-scoped-effect"><a class="header" href="#iteration-scoped-effect">Iteration (Scoped Effect)</a></h1>
<h2 id="feature-status-3"><a class="header" href="#feature-status-3">Feature Status</a></h2>
<p>The <code>Iterator</code> trait has been stable in Rust since 1.0, but the generator syntax
is currently <em>unstable</em>. This document will assume that generators are created
with the <code>gen</code> keyword, but that's for illustrative purposes only.</p>
<h2 id="description-4"><a class="header" href="#description-4">Description</a></h2>
<p>todo</p>
<h2 id="technical-overview"><a class="header" href="#technical-overview">Technical Overview</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td><code>gen</code></td></tr>
<tr><td>Yield</td><td><code>yield</code></td></tr>
<tr><td>Apply</td><td>N/A</td></tr>
<tr><td>Consume</td><td><code>for..in</code></td></tr>
<tr><td>Reification</td><td><code>impl Iterator</code></td></tr>
</tbody></table>
<h2 id="refinements-3"><a class="header" href="#refinements-3">Refinements</a></h2>
<table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody>
<tr><td>step</td><td>Has a notion of successor and predecessor operations.</td></tr>
<tr><td>trusted len ‚Ä†</td><td>Reports an accurate length using <code>size_hint</code>.</td></tr>
<tr><td>trusted step</td><td>Upholds all invariants of <code>Step</code>.</td></tr>
<tr><td>double-ended</td><td>Is able to yield elements from both ends.</td></tr>
<tr><td>exact size ‚Ä†</td><td>Knows its exact length.</td></tr>
<tr><td>fused</td><td>Always continues to yield <code>None</code> when exhausted.</td></tr>
</tbody></table>
<blockquote>
<p>‚Ä† The difference between <code>TrustedLen</code> and <code>ExactSizeIterator</code> is that
<code>TrustedLen</code> is marked as <code>unsafe</code> to implement while <code>ExactSizeIterator</code> is
marked as <em>safe</em> to implement. This means that if <code>TrustedLen</code> is implemented,
you can rely on it for safety purposes, while with <code>ExactSizeIterator</code> you
cannot.</p>
</blockquote>
<h2 id="positions-available-2"><a class="header" href="#positions-available-2">Positions Available</a></h2>
<table><thead><tr><th>Position</th><th>Available</th><th>Example</th></tr></thead><tbody>
<tr><td>Manual trait impl</td><td>‚úÖ</td><td><code>impl Iterator for Cat {}</code></td></tr>
<tr><td>Free functions</td><td>‚ùå</td><td><code>gen fn meow() {}</code></td></tr>
<tr><td>Inherent functions</td><td>‚ùå</td><td><code>impl Cat { gen fn meow() {} } </code></td></tr>
<tr><td>Trait methods</td><td>‚ùå</td><td><code>trait Cat { gen fn meow() {} }</code></td></tr>
<tr><td>Trait declarations</td><td>‚ùå</td><td><code>gen trait Cat {}</code></td></tr>
<tr><td>Block scope</td><td>‚ùå</td><td>N/A</td></tr>
<tr><td>Argument qualifiers</td><td>‚ùå</td><td><code>fn meow(cat: impl gen Cat) {}</code></td></tr>
<tr><td>Drop</td><td>‚ùå</td><td><code>impl gen Drop for Cat {}</code></td></tr>
<tr><td>Closures</td><td>‚ùå</td><td><code>gen «Ä«Ä  {}</code></td></tr>
<tr><td>Iterators</td><td>‚ùå</td><td><code>for cat in cats {}</code></td></tr>
</tbody></table>
<h2 id="interactions-with-other-effects-3"><a class="header" href="#interactions-with-other-effects-3">Interactions with other effects</a></h2>
<h3 id="asynchrony-3"><a class="header" href="#asynchrony-3">Asynchrony</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>iterator of futures</td></tr>
<tr><td>Description</td><td>Creates an iterator of futures. The future takes the iterator by <code>&amp;mut self</code>, so only a single future may be executed concurrently</td></tr>
<tr><td>Example</td><td><a href="https://docs.rs/async-iterator/latest/async_iterator/"><code>AsyncIterator</code></a></td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>No, async functions in traits are unstable</td></tr>
</tbody></table>
<h3 id="fallibility-3"><a class="header" href="#fallibility-3">Fallibility</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>iterator of tryables</td></tr>
<tr><td>Description</td><td>Creates an iterator of tryables, typically an iterator of <code>Result</code></td></tr>
<tr><td>Example</td><td><a href="https://docs.rs/fallible-iterator/latest/fallible_iterator/trait.FallibleIterator.html"><code>FallibleIterator</code></a></td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>No, try in traits is not available</td></tr>
</tbody></table>
<h3 id="compile-time-execution-3"><a class="header" href="#compile-time-execution-3">Compile-time Execution</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>const iterator</td></tr>
<tr><td>Description</td><td>Creates an iterator which can be iterated over at compile-time</td></tr>
<tr><td>Example</td><td>N/A</td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>No, const traits are unstable</td></tr>
</tbody></table>
<h3 id="thread-safety-3"><a class="header" href="#thread-safety-3">Thread-Safety</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>iterator of tryables</td></tr>
<tr><td>Description</td><td>Creates an iterator whose items which can be sent across threads</td></tr>
<tr><td>Example</td><td><code>where I: Iterator&lt;Item = T&gt;, T: Send</code></td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>Yes, as a bound on use. And by unit-testing the <code>Send</code> auto-trait on decls.</td></tr>
</tbody></table>
<h3 id="immovability-2"><a class="header" href="#immovability-2">Immovability</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>an iterator which takes <code>self: Pin&lt;&amp;mut Self&gt;</code></td></tr>
<tr><td>Description</td><td>An iterator which itself holds onto self-referential data</td></tr>
<tr><td>Example</td><td>N/A</td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>Yes</td></tr>
</tbody></table>
<h3 id="unwinding-2"><a class="header" href="#unwinding-2">Unwinding</a></h3>
<table><thead><tr><th>Overview</th><th>Description</th></tr></thead><tbody>
<tr><td>Composition</td><td>iterator may panic instead of yield</td></tr>
<tr><td>Description</td><td>Creates an iterator which may panic</td></tr>
<tr><td>Example</td><td><code>Iterator</code> (may panic by default)</td></tr>
<tr><td>Implementable as of Rust 1.70?</td><td>Yes, but cannot opt-out of &quot;may panic&quot; semantics</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unwinding-scoped-effect"><a class="header" href="#unwinding-scoped-effect">Unwinding (Scoped Effect)</a></h1>
<h2 id="feature-status-4"><a class="header" href="#feature-status-4">Feature Status</a></h2>
<p>todo</p>
<h2 id="description-5"><a class="header" href="#description-5">Description</a></h2>
<p>todo</p>
<h2 id="refinements-4"><a class="header" href="#refinements-4">Refinements</a></h2>
<table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody>
</tbody></table>
<p>The <code>panic</code> effect currently has no refinements.</p>
<h2 id="feature-categorization-3"><a class="header" href="#feature-categorization-3">Feature categorization</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td>N/A</td></tr>
<tr><td>Yield</td><td><code>panic!</code></td></tr>
<tr><td>Apply</td><td><code>foo()</code> / <code>resume_unwind</code></td></tr>
<tr><td>Consume</td><td><code>catch_unwind</code> / <code>fn main</code></td></tr>
<tr><td>Reification</td><td>N/A</td></tr>
</tbody></table>
<p>Panics differ from all other control-flow oriented effects because every
function is assumed to potentially panic. This means that the syntax to forward
a panic from a function is just a regular function call. Panics are not
represented in the type system, instead they exist as a property <em>outside</em> of
it.</p>
<h2 id="interactions-with-other-effects-4"><a class="header" href="#interactions-with-other-effects-4">Interactions with other effects</a></h2>
<h3 id="asynchrony-4"><a class="header" href="#asynchrony-4">Asynchrony</a></h3>
<h3 id="compile-time-execution-4"><a class="header" href="#compile-time-execution-4">Compile-time Execution</a></h3>
<h3 id="fallibility-4"><a class="header" href="#fallibility-4">Fallibility</a></h3>
<h3 id="iteration-3"><a class="header" href="#iteration-3">Iteration</a></h3>
<h3 id="unwinding-3"><a class="header" href="#unwinding-3">Unwinding</a></h3>
<h3 id="memory-safety-2"><a class="header" href="#memory-safety-2">Memory-Safety</a></h3>
<h3 id="immovability-3"><a class="header" href="#immovability-3">Immovability</a></h3>
<h3 id="object-safety-3"><a class="header" href="#object-safety-3">Object-Safety</a></h3>
<h3 id="ownership-3"><a class="header" href="#ownership-3">Ownership</a></h3>
<h3 id="thread-safety-4"><a class="header" href="#thread-safety-4">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-safety-scoped-effect"><a class="header" href="#memory-safety-scoped-effect">Memory Safety (Scoped Effect)</a></h1>
<h3 id="asynchrony-5"><a class="header" href="#asynchrony-5">Asynchrony</a></h3>
<h3 id="compile-time-execution-5"><a class="header" href="#compile-time-execution-5">Compile-time Execution</a></h3>
<h3 id="fallibility-5"><a class="header" href="#fallibility-5">Fallibility</a></h3>
<h3 id="iteration-4"><a class="header" href="#iteration-4">Iteration</a></h3>
<h3 id="unwinding-4"><a class="header" href="#unwinding-4">Unwinding</a></h3>
<h3 id="memory-safety-3"><a class="header" href="#memory-safety-3">Memory-Safety</a></h3>
<h3 id="immovability-4"><a class="header" href="#immovability-4">Immovability</a></h3>
<h3 id="object-safety-4"><a class="header" href="#object-safety-4">Object-Safety</a></h3>
<h3 id="ownership-4"><a class="header" href="#ownership-4">Ownership</a></h3>
<h3 id="thread-safety-5"><a class="header" href="#thread-safety-5">Thread-Safety</a></h3>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://blog.yoshuawuyts.com/unsafe-syntax/">Keywords I: Unsafe Syntax</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="immovability-data-type-effect"><a class="header" href="#immovability-data-type-effect">Immovability (Data-Type Effect)</a></h1>
<h2 id="interactions-with-other-effects-5"><a class="header" href="#interactions-with-other-effects-5">Interactions with other effects</a></h2>
<h3 id="asynchrony-6"><a class="header" href="#asynchrony-6">Asynchrony</a></h3>
<h3 id="compile-time-execution-6"><a class="header" href="#compile-time-execution-6">Compile-time Execution</a></h3>
<h3 id="fallibility-6"><a class="header" href="#fallibility-6">Fallibility</a></h3>
<h3 id="iteration-5"><a class="header" href="#iteration-5">Iteration</a></h3>
<h3 id="unwinding-5"><a class="header" href="#unwinding-5">Unwinding</a></h3>
<h3 id="memory-safety-4"><a class="header" href="#memory-safety-4">Memory-Safety</a></h3>
<h3 id="immovability-5"><a class="header" href="#immovability-5">Immovability</a></h3>
<h3 id="object-safety-5"><a class="header" href="#object-safety-5">Object-Safety</a></h3>
<h3 id="ownership-5"><a class="header" href="#ownership-5">Ownership</a></h3>
<h3 id="thread-safety-6"><a class="header" href="#thread-safety-6">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-safety-data-type-effect"><a class="header" href="#object-safety-data-type-effect">Object Safety (Data-Type Effect)</a></h1>
<h3 id="asynchrony-7"><a class="header" href="#asynchrony-7">Asynchrony</a></h3>
<h3 id="compile-time-execution-7"><a class="header" href="#compile-time-execution-7">Compile-time Execution</a></h3>
<h3 id="fallibility-7"><a class="header" href="#fallibility-7">Fallibility</a></h3>
<h3 id="iteration-6"><a class="header" href="#iteration-6">Iteration</a></h3>
<h3 id="unwinding-6"><a class="header" href="#unwinding-6">Unwinding</a></h3>
<h3 id="memory-safety-5"><a class="header" href="#memory-safety-5">Memory-Safety</a></h3>
<h3 id="immovability-6"><a class="header" href="#immovability-6">Immovability</a></h3>
<h3 id="object-safety-6"><a class="header" href="#object-safety-6">Object-Safety</a></h3>
<h3 id="ownership-6"><a class="header" href="#ownership-6">Ownership</a></h3>
<h3 id="thread-safety-7"><a class="header" href="#thread-safety-7">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-data-type-effect"><a class="header" href="#ownership-data-type-effect">Ownership (Data-Type Effect)</a></h1>
<h2 id="description-6"><a class="header" href="#description-6">Description</a></h2>
<h2 id="feature-status-5"><a class="header" href="#feature-status-5">Feature Status</a></h2>
<h2 id="feature-categorization-4"><a class="header" href="#feature-categorization-4">Feature categorization</a></h2>
<table><thead><tr><th>Position</th><th>Syntax</th></tr></thead><tbody>
<tr><td>Effect</td><td></td></tr>
<tr><td>Yield</td><td></td></tr>
<tr><td>Apply</td><td></td></tr>
<tr><td>Consume</td><td></td></tr>
<tr><td>Reification</td><td></td></tr>
</tbody></table>
<h2 id="positions-available-3"><a class="header" href="#positions-available-3">Positions Available</a></h2>
<table><thead><tr><th>Position</th><th>Available</th><th>Example</th></tr></thead><tbody>
<tr><td>Manual trait impl</td><td>‚úÖ</td><td><code>impl Future for Cat {}</code></td></tr>
<tr><td>Free functions</td><td>‚úÖ</td><td><code>async fn meow() {}</code></td></tr>
<tr><td>Inherent functions</td><td>‚úÖ</td><td><code>impl Cat { async fn meow() {} } </code></td></tr>
<tr><td>Trait methods</td><td>‚è≥</td><td><code>trait Cat { async fn meow() {} }</code></td></tr>
<tr><td>Trait declarations</td><td>‚ùå</td><td><code>async trait Cat {}</code></td></tr>
<tr><td>Block scope</td><td>‚úÖ</td><td><code>fn meow() { async {} }</code></td></tr>
<tr><td>Argument qualifiers</td><td>‚ùå</td><td><code>fn meow(cat: impl async Cat) {}</code></td></tr>
<tr><td>Data types ‚Ä†</td><td>‚ùå</td><td><code>async struct Cat {}</code></td></tr>
<tr><td>Drop ‚Ä†</td><td>‚ùå</td><td><code>impl async Drop for Cat {}</code></td></tr>
<tr><td>Closures</td><td>‚ùå</td><td><code>async «Ä«Ä  {}</code></td></tr>
<tr><td>Iterators</td><td>‚ùå</td><td><code>for await cat in cats {}</code></td></tr>
</tbody></table>
<h2 id="refinements-5"><a class="header" href="#refinements-5">Refinements</a></h2>
<table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody>
</tbody></table>
<h2 id="interactions-with-other-effects-6"><a class="header" href="#interactions-with-other-effects-6">Interactions with other effects</a></h2>
<h3 id="asynchrony-8"><a class="header" href="#asynchrony-8">Asynchrony</a></h3>
<h3 id="compile-time-execution-8"><a class="header" href="#compile-time-execution-8">Compile-time Execution</a></h3>
<h3 id="fallibility-8"><a class="header" href="#fallibility-8">Fallibility</a></h3>
<h3 id="iteration-7"><a class="header" href="#iteration-7">Iteration</a></h3>
<h3 id="unwinding-7"><a class="header" href="#unwinding-7">Unwinding</a></h3>
<h3 id="memory-safety-6"><a class="header" href="#memory-safety-6">Memory-Safety</a></h3>
<h3 id="immovability-7"><a class="header" href="#immovability-7">Immovability</a></h3>
<h3 id="object-safety-7"><a class="header" href="#object-safety-7">Object-Safety</a></h3>
<h3 id="ownership-7"><a class="header" href="#ownership-7">Ownership</a></h3>
<h3 id="thread-safety-8"><a class="header" href="#thread-safety-8">Thread-Safety</a></h3>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://blog.yoshuawuyts.com/const-syntax/">Keywords II: Const Syntax</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thread-safety-data-type-effect"><a class="header" href="#thread-safety-data-type-effect">Thread-Safety (Data-Type Effect)</a></h1>
<h2 id="interactions-with-other-effects-7"><a class="header" href="#interactions-with-other-effects-7">Interactions with other effects</a></h2>
<h3 id="asynchrony-9"><a class="header" href="#asynchrony-9">Asynchrony</a></h3>
<h3 id="compile-time-execution-9"><a class="header" href="#compile-time-execution-9">Compile-time Execution</a></h3>
<h3 id="fallibility-9"><a class="header" href="#fallibility-9">Fallibility</a></h3>
<h3 id="iteration-8"><a class="header" href="#iteration-8">Iteration</a></h3>
<h3 id="unwinding-8"><a class="header" href="#unwinding-8">Unwinding</a></h3>
<h3 id="memory-safety-7"><a class="header" href="#memory-safety-7">Memory-Safety</a></h3>
<h3 id="immovability-8"><a class="header" href="#immovability-8">Immovability</a></h3>
<h3 id="object-safety-8"><a class="header" href="#object-safety-8">Object-Safety</a></h3>
<h3 id="ownership-8"><a class="header" href="#ownership-8">Ownership</a></h3>
<h3 id="thread-safety-9"><a class="header" href="#thread-safety-9">Thread-Safety</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implications-of-the-effect-hierarchy"><a class="header" href="#implications-of-the-effect-hierarchy">Implications of the effect hierarchy</a></h1>
<p>One implication of the subset-superset relationship is that code which is
generic over effects will not be able to use all functionality of the superset
in the subset case. Though it will need to use the <em>syntax</em> of the superset.</p>
<p>Take for examle the following code. It takes two async closures, awaits them,
and sums them:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sum the output of two async functions:
~async fn sum&lt;T&gt;(
    lhs: impl ~async FnMut() -&gt; T,
    rhs: impl ~async FnMut() -&gt; T
) -&gt; T {
   let lhs = lhs().await; 
   let rhs = rhs().await; 
   lhs + rhs
}
<span class="boring">}
</span></code></pre></pre>
<p>One of the benefits of async execution is that we gain <em>ad-hoc concurrency</em>, so
we might be tempted to perform the comptutation of <code>lhs</code> and <code>rhs</code> concurrently,
and summing the output once both have completed. However this should not be
possible solely using effect polymorphism since the generated code needs to work
in both async and non-async contexts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sum the output of two async functions:
~async fn sum&lt;T&gt;(
    lhs: impl ~async FnMut() -&gt; T,
    rhs: impl ~async FnMut() -&gt; T
) -&gt; T {
   let (lhs, rhs) = (lhs(), rhs()).join().await;
   //                             ^^^^^^^
   // error: cannot call an `async fn` from a `~async` context
   // hint: instead of calling `join` await the items sequentially
   //       or consider writing an overload instead
   lhs + rhs
}
<span class="boring">}
</span></code></pre></pre>
<p>And this is not unique to <code>async</code>: in maybe-<code>const</code> contexts we cannot call
functions from the super-context (&quot;base Rust&quot;) since those cannot work during
<code>const</code> execution. This leads to the following implication: <strong>Conditional effect
implementations require the syntactic annotations of the super-context, but
cannot call functions which exclusively work in the super-context.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grouping-keyword-generics"><a class="header" href="#grouping-keyword-generics">Grouping Keyword Generics</a></h1>
<p>We expect it to be common that if a function takes generics and has conditional
keywords on those, it will want to be conditional over <em>all</em> keywords on those
generics. So in order to not have people repeat params over and over, we should
provide shorthand syntax.</p>
<p>Here is the &quot;base&quot; variant we're changing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// without any effects
fn find&lt;I&gt;(
    iter: impl Iterator&lt;Item = I&gt;,
    closure: impl FnMut(&amp;I) -&gt; bool,
) -&gt; Option&lt;I&gt; {
    ...    
}
<span class="boring">}
</span></code></pre></pre>
<p>We could imagine wanting a fallible variant of this which can short-circuit
based on whether an <code>Error</code> is returned or not. We could imagine the &quot;base&quot;
version using a <code>TryTrait</code> notation, and the &quot;effect&quot; version using the <code>throws</code>
keyword. Both variants would look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// fallible without effect notation
fn try_find&lt;I, E&gt;(
    iter: impl TryIterator&lt;Item = I, E&gt;,
    closure: impl TryFnMut&lt;(&amp;I), E&gt; -&gt; bool,
) -&gt; Result&lt;Option&lt;I&gt;, E&gt; {
    ...
}

// fallible with effect notation
fn try_find&lt;I, E&gt;(
    iter: impl Iterator&lt;Item = I&gt; ~yeets E,
    closure: impl FnMut(&amp;I) ~yeets E -&gt; bool,
) -&gt; Option&lt;I&gt; ~yeets E {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For <code>async</code> we could do something similar. The &quot;base&quot; version would use
<code>AsyncTrait</code> variants. And the &quot;effect&quot; variant would use the <code>async</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// async without effect notation
fn async_find&lt;I&gt;(
    iter: impl AsyncIterator&lt;Item = I&gt;,
    closure: impl AsyncFnMut(&amp;I) -&gt; bool,
) -&gt; impl Future&lt;Output = Option&lt;I&gt;&gt; {
    ...
}

// async with effect notation
~async fn async_find&lt;I&gt;(
    iter: impl ~async Iterator&lt;Item = I&gt;,
    closure: impl ~async FnMut(&amp;I) -&gt; bool,
) -&gt; Option&lt;I&gt; {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Both the &quot;fallible&quot; and &quot;async&quot; variants mirror each other closely. And it's
easy to imagine we'd want to be conditional over both. However, if neither the
&quot;base&quot; or the &quot;effect&quot; variants are particularly pleasant.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// async + fallible without effect notation
fn try_async_find&lt;I, E&gt;(
    iter: impl TryAsyncIterator&lt;Item = Result&lt;I, E&gt;&gt;,
    closure: impl TryAsyncFnMut&lt;(&amp;I), E&gt; -&gt; bool,
) -&gt; impl Future&lt;Output = Option&lt;Result&lt;I, E&gt;&gt;&gt; {
    ...
}

// async + fallible with effect notation
~async fn try async_find&lt;I, E&gt;(
    iter: impl ~async Iterator&lt;Item = I&gt; ~yeets E,
    closure: impl ~async FnMut(&amp;I) ~yeets E -&gt; bool,
) -&gt; Option&lt;I&gt; ~yeets E {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The &quot;base&quot; variant is entirely unworkable since it introduces a combinatorial
explosion of effects (&quot;fallible&quot; and &quot;async&quot; are only two examples of effects).
The &quot;effect&quot; variant is a little better because it composes, but even with just
two effects it looks utterly overwhelming. Can you imagine what it would look
like with three or four? Yikes.</p>
<p>So what if we could instead treat effects as an actual generic parameter? As we
discussed earlier, in order to lower effects we already need a new type of
generic at the MIR layer. But what if we exposed that type of generics as user
syntax too? We could imagine it to look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// conditional
fn any_find&lt;I, effect F&gt;(
    iter: impl F * Iterator&lt;Item = I&gt;,
    closure: impl F * FnMut(&amp;I) -&gt; bool,
) -&gt; F * Option&lt;I&gt; {
    ...    
}
<span class="boring">}
</span></code></pre></pre>
<p>There are legitimate questions here though. Effects which provide a superset of
base Rust may change the way we write Rust. The clearest example of this is
<code>async</code>: would having an <code>effect F</code> require that we when we invoke our <code>closure</code>
that we suffix it with <code>.await</code>? What about a <code>try</code> effect, would that require
that we suffix it with a <code>?</code> operator? The effects passed to the function might
need to change the way we author the function body <sup class="footnote-reference"><a href="#implication">1</a></sup>.</p>
<div class="footnote-definition" id="implication"><sup class="footnote-definition-label">1</sup>
<p>One interesting thing to keep in mind is that the total set of
effects is strictly <em>bounded</em>. None of these mechanisms would be exposed to
end-users to define their own effects, but only used by the Rust language. This
means we can know which effects are part of the set. And any change in calling
signature (e.g. adding <code>.await</code> or <code>?</code>, etc.) can be part of a Rust edition.</p>
</div>
<p>Another question is about <em>bounds</em>. Declaring an <code>effect F</code> is maximally
inclusive: it would capture all effects. Should we be able to place restrictions
on this effect, and if so what should that look like?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-new-keyword-generics"><a class="header" href="#adding-new-keyword-generics">Adding new keyword generics</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() { // maybe const context
    let file = fs::open(&quot;hello&quot;).unwrap();
    // compile error! =&gt; `fs::open` is not a maybe const function!
}

~base fn foo() { // assume `const` as the default; invert the relationship
    let file = fs::open(&quot;hello&quot;).unwrap();
    // compile error! =&gt; `fs::open` is
    // a base function which cannot be
    // called from a maybe base context
}

~async fn foo() {
    let file = my_definitely_async_fn().await;
    // compile error!
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">fn foo&lt;effect F: const&gt;(f: impl F * Fn() -&gt; ()) {
    f();
}
fn foo&lt;effect F: const&gt;(f: impl effect&lt;F&gt; Fn() -&gt; ()) {
    f();
}

// compile error!
// effect `F` is maximally inclusive!
// missing `.await`

// maximally inclusive effects are not forward compatible! - once
// we add a new effect existing code will not compile!
// The calling convention may change each time we add a new effect!

fn main() {
    foo(some_fn); // Infer all effects to Not*
}
</code></pre></pre>
<p>Adding new effects to the language does not break anyone, because effects must
be opted in. Adding a new effect to the opt-in effect generics of a function
will break callers that infer the effect to be required.</p>
<p>Editions can add new effects to the list of defaults. This is not a breaking
change because calling crates can stay on old editions, even if the lib crate
got updated to a newer edition. THe lower edition crates don't see the defaults
and turn them off.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mir-desugaring"><a class="header" href="#mir-desugaring">MIR desugaring</a></h1>
<p><a href="https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/complexity.20of.20constness.20in.20the.20type.20system">Recently</a>
I (Oli) have proposed to add a magic generic parameter on all <code>const fn foo</code>,
<code>impl const Foo for Bar</code> and <code>const trait Foo</code> declarations. This generic
parameter (called <code>constness</code> henceforth) is forwarded automatically to all
items used within the body of a const fn. The following code blocks demonstrates
the way I envision this magic generic parameter to be created (TLDR: similar to
desugarings).</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="trait-declarations"><a class="header" href="#trait-declarations">Trait declarations</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const trait Foo {}
<span class="boring">}
</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;constness C&gt; {}
<span class="boring">}
</span></code></pre></pre>
<h4 id="generic-parameters"><a class="header" href="#generic-parameters">Generic parameters</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo&lt;T: Bar + ~const Foo&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;constness C, T: Bar + Foo&lt;C&gt;&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<h4 id="function-bodies"><a class="header" href="#function-bodies">Function bodies</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() {
    bar()
}
<span class="boring">}
</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;constness C&gt;() {
    bar::&lt;C&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="call-sites-outside-of-const-contexts"><a class="header" href="#call-sites-outside-of-const-contexts">Call sites outside of const contexts</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    some_const_fn();
}
</code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    some_const_fn::&lt;constness::NotConst&gt;();
}
</code></pre></pre>
<h4 id="call-sites-in-const-contexts"><a class="header" href="#call-sites-in-const-contexts">Call sites in const contexts</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MOO: () = {
    some_const_fn();
}
<span class="boring">}
</span></code></pre></pre>
<p>becomes</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MOO: () = {
    some_const_fn::&lt;constness::ConstRequired&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="implementation-side"><a class="header" href="#implementation-side">Implementation side:</a></h3>
<p>We add a fourth kind of generic parameter: <code>constness</code>. All <code>const trait Foo</code>
implicitly get that parameter. In rustc we remove the <code>constness</code> field from
<code>TraitPredicate</code> and instead rely on generic parameter substitutions to replace
constness parameters. For now such a generic parameter can either be
<code>Constness::Required</code>, <code>Constness::Not</code> or <code>Constness::Param</code>, where only the
latter is replaced during substitutions, the other two variants are fixed.
Making this work as generic parameter substitution should allow us to re-use all
the existing logic for such substitutions instead of rolling them again. I am
aware of a significant amount of hand-waving happening here, most notably around
where the substitutions are coming from, but I'm hoping we can hash that out in
an explorative implementation</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overloading-keyword-generics"><a class="header" href="#overloading-keyword-generics">Overloading Keyword Generics</a></h1>
<p>In the previous section we saw that we cannot use <code>join</code> to await two futures
concurrently because in &quot;base Rust&quot; we cannot run two closures concurrently. The
capabilities introduced by the superset (async) have no counterpart in the
subset (&quot;base Rust&quot;), and therefore we cannot write it.</p>
<p>But sometimes we <em>do</em> want to be able to specialize implementations for a
specific context, making use of the capabilities they provide. In order to do
this we need to be able to declare two different code paths, and we propose
<em>effect overloading</em> as the mechanism to do that.</p>
<p>This problem is not limited to async Rust either; const implementations may want
to swap to platform-specific intrinsics at runtime, but keep using portable
instructions during CTFE. This is only a difference in implementation, and
should not require users to switch between APIs.</p>
<p>The way we envision <em>effect overloading</em> to work would be similar to
specialization. A base implementation would be declared, with an overload in the
same scope using the same signature except for the effects. The compiler would
pick up on that, and make it work as if the type was written in a polymorphic
fashion. Taking our earlier example, we could imagine the <code>sum</code> function could
then be written like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sum the output of two functions:
default fn sum&lt;T&gt;(
    lhs: impl FnMut() -&gt; T,
    rhs: impl FnMut() -&gt; T
) -&gt; T {
   lhs() + rhs()
}

async fn sum&lt;T&gt;(
    lhs: impl async FnMut() -&gt; T,
    rhs: impl async FnMut() -&gt; T
) -&gt; T {
   let (lhs, rhs) = (lhs(), rhs()).join().await;
   lhs + rhs
}
<span class="boring">}
</span></code></pre></pre>
<p>We expect <em>effect overloading</em> to not only be useful for performance: we suspect
it may also be required when defining the core (async) IO types in the stdlib
(e.g. <code>TcpStream</code>, <code>File</code>). These types carry extra fields which their base
counterparts do not. And operations such as reading and writing to them cannot
be written in a polymorphic fashion.</p>
<p><strong>While we expect a majority of ecosystem and stdlib code to be written using
<em>effect polymorphism</em>, there is a point at which implementations do need to be
specialized, and for that we need <em>effect overloading</em>.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prior-art-2"><a class="header" href="#prior-art-2">Prior Art</a></h1>
<h2 id="c-noexceptnoexcept"><a class="header" href="#c-noexceptnoexcept">C++: <code>noexcept(noexcept(‚Ä¶))</code></a></h2>
<p>C++'s <code>noexcept(noexcept(‚Ä¶))</code> pattern is used to declare something as <code>noexcept</code>
if the evaluated pattern is also <code>noexcept</code>. This makes <code>noexcept</code> conditional
on the pattern provided.</p>
<p>This is most commonly used in generic templates to mark the output type as
<code>noexcept</code> if all of the input types are <code>noexcept</code> as well.</p>
<ul>
<li><a href="https://devblogs.microsoft.com/oldnewthing/20220408-00/?p=106438">Raymond Chen, ‚ÄúPlease Repeat Yourself: The Noexcept(Noexcept(‚Ä¶)) Idiom,‚Äù The Old New Thing, April 8, 2022</a></li>
</ul>
<h2 id="c-implicits-and-constexpr"><a class="header" href="#c-implicits-and-constexpr">C++: implicits and <code>constexpr</code></a></h2>
<p><code>constexpr</code> can be applied based on a condition. The following example works:</p>
<h4 id="c-11"><a class="header" href="#c-11">C++ 11</a></h4>
<pre><code class="language-cpp">template &lt;
class U = T,
detail::enable_if_t&lt;std::is_convertible&lt;U &amp;&amp;, T&gt;::value&gt; * = nullptr,
detail::enable_forward_value&lt;T, U&gt; * = nullptr&gt;
constexpr optional(U &amp;&amp;u) : base(in_place, std::forward&lt;U&gt;(u)) {}

template &lt;
class U = T,
detail::enable_if_t&lt;!std::is_convertible&lt;U &amp;&amp;, T&gt;::value&gt; * = nullptr,
detail::enable_forward_value&lt;T, U&gt; * = nullptr&gt;
constexpr explicit optional(U &amp;&amp;u) : base(in_place, std::forward&lt;U&gt;(u)) {}
</code></pre>
<h4 id="c-20"><a class="header" href="#c-20">C++ 20</a></h4>
<pre><code class="language-cpp">template &lt;
class U = T,
detail::enable_forward_value&lt;T, U&gt; * = nullptr&gt;
explicit(std::is_convertible&lt;U &amp;&amp;, T&gt;::value) constexpr optional(U &amp;&amp;u) : base(in_place, std::forward&lt;U&gt;(u)) {}
</code></pre>
<p><strong>todo:</strong> validate what this does exactly by someone who can actually read C++.</p>
<h2 id="rust-maybe-async-crate"><a class="header" href="#rust-maybe-async-crate">Rust: <code>maybe-async</code> crate</a></h2>
<ul>
<li><a href="https://crates.io/crates/maybe-async">fmeow, ‚Äúmaybe-async crate,‚Äù January 15, 2020</a></li>
</ul>
<h2 id="rust-fn-main"><a class="header" href="#rust-fn-main">Rust: <code>fn main</code></a></h2>
<p>Rust provides overloads for <code>async fn main</code> through the <code>Termination</code> trait. The
<code>main</code> function can optionally be made fallible by defining <code>-&gt; Result&lt;()&gt;</code> as
the return type. In the ecosystem it's common to extend <code>fn main</code> with async
capabilities by annotating it with an attribute. And this mechanism has been
shown to work in the compiler as well by implementing <code>Termination for F: Future</code>.</p>
<p>The mechanism of overloading for <code>fn main</code> differs from what we're proposing,
but the outcomes are functionally the same: greater flexibility in which
function modifiers are accepted, and less need to duplicate / wrap code.</p>
<h2 id="zig-async-functions"><a class="header" href="#zig-async-functions">Zig: async functions</a></h2>
<blockquote>
<p>Zig infers whether a function is async, and allows async/await on non-async
functions, which means that Zig libraries are agnostic of blocking vs async I/O.
Zig avoids function colors.</p>
</blockquote>
<p>‚Äî <a href="https://ziglang.org/learn/overview/#concurrency-via-async-functions">Zig contributors, ‚ÄúZig In-Depth Overview: Concurrency via Async Functions,‚Äù October 1, 2019</a></p>
<h2 id="swift-async-overloading"><a class="header" href="#swift-async-overloading">Swift: async overloading</a></h2>
<pre><code class="language-swift">// Existing synchronous API
func doSomethingElse() { ... }

// New and enhanced asynchronous API
func doSomethingElse() async { ... }
</code></pre>
<ul>
<li>https://github.com/apple/swift-evolution/pull/1392</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
